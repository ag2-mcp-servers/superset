# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T10:13:40+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Union
from uuid import UUID

from pydantic import BaseModel, Field, RootModel, confloat, conint, constr


class AnnotationType(Enum):
    FORMULA = 'FORMULA'
    INTERVAL = 'INTERVAL'
    EVENT = 'EVENT'
    TIME_SERIES = 'TIME_SERIES'


class Opacity(Enum):
    field_ = ''
    opacityLow = 'opacityLow'
    opacityMedium = 'opacityMedium'
    opacityHigh = 'opacityHigh'


class SourceType(Enum):
    field_ = ''
    line = 'line'
    NATIVE = 'NATIVE'
    table = 'table'


class Style(Enum):
    dashed = 'dashed'
    dotted = 'dotted'
    solid = 'solid'
    longDashed = 'longDashed'


class AnnotationLayer(BaseModel):
    annotationType: Optional[AnnotationType] = Field(
        None, description='Type of annotation layer'
    )
    color: Optional[str] = Field(None, description='Layer color')
    descriptionColumns: Optional[List[str]] = Field(
        None,
        description='Columns to use as the description. If none are provided, all will be shown.',
    )
    hideLine: Optional[bool] = Field(
        None, description='Should line be hidden. Only applies to line annotations'
    )
    intervalEndColumn: Optional[str] = Field(
        None,
        description='Column containing end of interval. Only applies to interval layers',
    )
    name: str = Field(..., description='Name of layer')
    opacity: Optional[Opacity] = Field(None, description='Opacity of layer')
    overrides: Optional[Dict[str, Any]] = Field(
        None, description='which properties should be overridable'
    )
    show: bool = Field(..., description='Should the layer be shown')
    showMarkers: bool = Field(
        ..., description='Should markers be shown. Only applies to line annotations.'
    )
    sourceType: Optional[SourceType] = Field(
        None, description='Type of source for annotation data'
    )
    style: Optional[Style] = Field(
        None, description='Line style. Only applies to time-series annotations'
    )
    timeColumn: Optional[str] = Field(
        None, description='Column with event date or interval start date'
    )
    titleColumn: Optional[str] = Field(None, description='Column with title')
    value: Any = Field(
        ...,
        description='For formula annotations, this contains the formula. For other types, this is the primary key of the source object.',
    )
    width: Optional[confloat(ge=0.0)] = Field(
        None, description='Width of annotation line'
    )


class AnnotationLayerRestApiGet(BaseModel):
    descr: Optional[str] = None
    id: Optional[int] = None
    name: Optional[constr(max_length=250)] = None


class AnnotationLayerRestApiPost(BaseModel):
    descr: Optional[str] = Field(
        None, description='Give a description for this annotation layer'
    )
    name: Optional[constr(min_length=1, max_length=250)] = Field(
        None, description='The annotation layer name'
    )


class AnnotationLayerRestApiPut(BaseModel):
    descr: Optional[str] = Field(
        None, description='Give a description for this annotation layer'
    )
    name: Optional[constr(min_length=1, max_length=250)] = Field(
        None, description='The annotation layer name'
    )


class AnnotationRestApiPost(BaseModel):
    end_dttm: Optional[datetime] = Field(
        None, description='The annotation end date time'
    )
    json_metadata: Optional[str] = Field(None, description='JSON metadata')
    long_descr: Optional[str] = Field(None, description='A long description')
    short_descr: Optional[constr(min_length=1, max_length=500)] = Field(
        None, description='A short description'
    )
    start_dttm: Optional[datetime] = Field(
        None, description='The annotation start date time'
    )


class AnnotationRestApiPut(BaseModel):
    end_dttm: Optional[datetime] = Field(
        None, description='The annotation end date time'
    )
    json_metadata: Optional[str] = Field(None, description='JSON metadata')
    long_descr: Optional[str] = Field(None, description='A long description')
    short_descr: Optional[constr(min_length=1, max_length=500)] = Field(
        None, description='A short description'
    )
    start_dttm: Optional[datetime] = Field(
        None, description='The annotation start date time'
    )


class CacheRestApiGet(BaseModel):
    id: Optional[int] = None


class CacheRestApiGetList(BaseModel):
    id: Optional[int] = None


class CacheRestApiPost(BaseModel):
    id: Optional[int] = None


class CacheRestApiPut(BaseModel):
    id: Optional[int] = None


class ChartCacheScreenshotResponseSchema(BaseModel):
    cache_key: Optional[str] = Field(None, description='The cache key')
    chart_url: Optional[str] = Field(None, description='The url to render the chart')
    image_url: Optional[str] = Field(
        None, description='The url to fetch the screenshot'
    )


class Aggregate(Enum):
    AVG = 'AVG'
    COUNT = 'COUNT'
    COUNT_DISTINCT = 'COUNT_DISTINCT'
    MAX = 'MAX'
    MIN = 'MIN'
    SUM = 'SUM'


class ExpressionType(Enum):
    SIMPLE = 'SIMPLE'
    SQL = 'SQL'


class ChartDataAggregateOptionsSchema(BaseModel):
    aggregates: Optional[Dict[str, Any]] = Field(
        None,
        description='The keys are the name of the aggregate column to be created, and the values specify the details of how to apply the aggregation. If an operator requires additional options, these can be passed here to be unpacked in the operator call. The following numpy operators are supported: average, argmin, argmax, cumsum, cumprod, max, mean, median, nansum, nanmin, nanmax, nanmean, nanmedian, min, percentile, prod, product, std, sum, var. Any options required by the operator can be passed to the `options` object.\n\nIn the example, a new column `first_quantile` is created based on values in the column `my_col` using the `percentile` operator with the `q=0.25` parameter.',
        examples=[
            {
                'first_quantile': {
                    'column': 'my_col',
                    'operator': 'percentile',
                    'options': {'q': 0.25},
                }
            }
        ],
    )


class ChartDataAsyncResponseSchema(BaseModel):
    channel_id: Optional[str] = Field(
        None, description='Unique session async channel ID'
    )
    job_id: Optional[str] = Field(None, description='Unique async job ID')
    result_url: Optional[str] = Field(
        None, description='Unique result URL for fetching async query data'
    )
    status: Optional[str] = Field(None, description='Status value for async job')
    user_id: Optional[str] = Field(None, description='Requesting user ID')


class WhiskerType(Enum):
    tukey = 'tukey'
    min_max = 'min/max'
    percentile = 'percentile'


class ChartDataBoxplotOptionsSchema(BaseModel):
    groupby: Optional[List[str]] = None
    metrics: Optional[List] = Field(
        None,
        description='Aggregate expressions. Metrics can be passed as both references to datasource metrics (strings), or ad-hoc metricswhich are defined only within the query object. See `ChartDataAdhocMetricSchema` for the structure of ad-hoc metrics.',
    )
    percentiles: Optional[Any] = Field(
        None,
        description='Upper and lower percentiles for percentile whisker type.',
        examples=[[1, 99]],
    )
    whisker_type: WhiskerType = Field(
        ...,
        description='Whisker type. Any numpy function will work.',
        examples=['tukey'],
    )


class ChartDataColumn(BaseModel):
    column_name: Optional[str] = Field(
        None, description='The name of the target column', examples=['mycol']
    )
    type: Optional[str] = Field(
        None, description='Type of target column', examples=['BIGINT']
    )


class Orientation(Enum):
    row = 'row'
    column = 'column'


class ChartDataContributionOptionsSchema(BaseModel):
    orientation: Orientation = Field(
        ...,
        description='Should cell values be calculated across the row or column.',
        examples=['row'],
    )


class Type(Enum):
    druid = 'druid'
    table = 'table'


class ChartDataDatasource(BaseModel):
    id: int = Field(..., description='Datasource id')
    type: Optional[Type] = Field(None, description='Datasource type')


class RelativeEnd(Enum):
    today = 'today'
    now = 'now'


class RelativeStart(Enum):
    today = 'today'
    now = 'now'


class TimeGrainSqla(Enum):
    PT1S = 'PT1S'
    PT5S = 'PT5S'
    PT30S = 'PT30S'
    PT1M = 'PT1M'
    PT5M = 'PT5M'
    PT10M = 'PT10M'
    PT15M = 'PT15M'
    PT0_5H = 'PT0.5H'
    PT1H = 'PT1H'
    PT6H = 'PT6H'
    P1D = 'P1D'
    P1W = 'P1W'
    P1M = 'P1M'
    P0_25Y = 'P0.25Y'
    P1Y = 'P1Y'
    field_1969_12_28T00_00_00Z_P1W = '1969-12-28T00:00:00Z/P1W'
    field_1969_12_29T00_00_00Z_P1W = '1969-12-29T00:00:00Z/P1W'
    P1W_1970_01_03T00_00_00Z = 'P1W/1970-01-03T00:00:00Z'
    P1W_1970_01_04T00_00_00Z = 'P1W/1970-01-04T00:00:00Z'


class Op(Enum):
    field__ = '=='
    field___1 = '!='
    field_ = '>'
    field__1 = '<'
    field___2 = '>='
    field___3 = '<='
    LIKE = 'LIKE'
    ILIKE = 'ILIKE'
    IS_NULL = 'IS NULL'
    IS_NOT_NULL = 'IS NOT NULL'
    IN = 'IN'
    NOT_IN = 'NOT IN'
    REGEX = 'REGEX'
    IS_TRUE = 'IS TRUE'
    IS_FALSE = 'IS FALSE'


class ChartDataFilter(BaseModel):
    col: str = Field(..., description='The column to filter.', examples=['country'])
    op: Op = Field(..., description='The comparison operator.', examples=['IN'])
    val: Optional[Any] = Field(
        None,
        description='The value or values to compare against. Can be a string, integer, decimal or list, depending on the operator.',
        examples=[['China', 'France', 'Japan']],
    )


class ChartDataGeodeticParseOptionsSchema(BaseModel):
    altitude: Optional[str] = Field(
        None,
        description='Name of target column for decoded altitude. If omitted, altitude information in geodetic string is ignored.',
    )
    geodetic: str = Field(
        ..., description='Name of source column containing geodetic point strings'
    )
    latitude: str = Field(..., description='Name of target column for decoded latitude')
    longitude: str = Field(
        ..., description='Name of target column for decoded longitude'
    )


class ChartDataGeohashDecodeOptionsSchema(BaseModel):
    geohash: str = Field(
        ..., description='Name of source column containing geohash string'
    )
    latitude: str = Field(..., description='Name of target column for decoded latitude')
    longitude: str = Field(
        ..., description='Name of target column for decoded longitude'
    )


class ChartDataGeohashEncodeOptionsSchema(BaseModel):
    geohash: str = Field(
        ..., description='Name of target column for encoded geohash string'
    )
    latitude: str = Field(..., description='Name of source latitude column')
    longitude: str = Field(..., description='Name of source longitude column')


class ChartDataPivotOptionsSchema(BaseModel):
    aggregates: Optional[Dict[str, Any]] = Field(
        None,
        description='The keys are the name of the aggregate column to be created, and the values specify the details of how to apply the aggregation. If an operator requires additional options, these can be passed here to be unpacked in the operator call. The following numpy operators are supported: average, argmin, argmax, cumsum, cumprod, max, mean, median, nansum, nanmin, nanmax, nanmean, nanmedian, min, percentile, prod, product, std, sum, var. Any options required by the operator can be passed to the `options` object.\n\nIn the example, a new column `first_quantile` is created based on values in the column `my_col` using the `percentile` operator with the `q=0.25` parameter.',
        examples=[
            {
                'first_quantile': {
                    'column': 'my_col',
                    'operator': 'percentile',
                    'options': {'q': 0.25},
                }
            }
        ],
    )
    column_fill_value: Optional[str] = Field(
        None, description='Value to replace missing pivot columns names with.'
    )
    columns: Optional[List[str]] = None
    drop_missing_columns: Optional[bool] = Field(
        None,
        description='Do not include columns whose entries are all missing (default: `true`).',
    )
    marginal_distribution_name: Optional[str] = Field(
        None, description='Name of marginal distribution row/column. (default: `All`)'
    )
    marginal_distributions: Optional[bool] = Field(
        None, description='Add totals for row/column. (default: `false`)'
    )
    metric_fill_value: Optional[float] = Field(
        None,
        description='Value to replace missing values with in aggregate calculations.',
    )


class Operation(Enum):
    aggregate = 'aggregate'
    boxplot = 'boxplot'
    contribution = 'contribution'
    cum = 'cum'
    geodetic_parse = 'geodetic_parse'
    geohash_decode = 'geohash_decode'
    geohash_encode = 'geohash_encode'
    pivot = 'pivot'
    prophet = 'prophet'
    rolling = 'rolling'
    select = 'select'
    sort = 'sort'
    diff = 'diff'
    compare = 'compare'


class ChartDataPostProcessingOperation(BaseModel):
    operation: Operation = Field(
        ..., description='Post processing operation type', examples=['aggregate']
    )
    options: Optional[Dict[str, Any]] = Field(
        None,
        description='Options specifying how to perform the operation. Please refer to the respective post processing operation option schemas. For example, `ChartDataPostProcessingOperationOptions` specifies the required options for the pivot operation.',
        examples=[
            {
                'aggregates': {
                    'age_mean': {'column': 'age', 'operator': 'mean'},
                    'age_q1': {
                        'column': 'age',
                        'operator': 'percentile',
                        'options': {'q': 0.25},
                    },
                },
                'groupby': ['country', 'gender'],
            }
        ],
    )


class TimeGrain(Enum):
    PT1S = 'PT1S'
    PT5S = 'PT5S'
    PT30S = 'PT30S'
    PT1M = 'PT1M'
    PT5M = 'PT5M'
    PT10M = 'PT10M'
    PT15M = 'PT15M'
    PT0_5H = 'PT0.5H'
    PT1H = 'PT1H'
    PT6H = 'PT6H'
    P1D = 'P1D'
    P1W = 'P1W'
    P1M = 'P1M'
    P0_25Y = 'P0.25Y'
    P1Y = 'P1Y'
    field_1969_12_28T00_00_00Z_P1W = '1969-12-28T00:00:00Z/P1W'
    field_1969_12_29T00_00_00Z_P1W = '1969-12-29T00:00:00Z/P1W'
    P1W_1970_01_03T00_00_00Z = 'P1W/1970-01-03T00:00:00Z'
    P1W_1970_01_04T00_00_00Z = 'P1W/1970-01-04T00:00:00Z'


class ChartDataProphetOptionsSchema(BaseModel):
    confidence_interval: confloat(ge=0.0, le=1.0) = Field(
        ..., description='Width of predicted confidence interval', examples=[0.8]
    )
    monthly_seasonality: Optional[Any] = Field(
        None,
        description='Should monthly seasonality be applied. An integer value will specify Fourier order of seasonality, `None` will automatically detect seasonality.',
        examples=[False],
    )
    periods: int = Field(..., examples=[7])
    time_grain: TimeGrain = Field(
        ...,
        description='Time grain used to specify time period increments in prediction. Supports [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Durations) durations.',
        examples=['P1D'],
    )
    weekly_seasonality: Optional[Any] = Field(
        None,
        description='Should weekly seasonality be applied. An integer value will specify Fourier order of seasonality, `None` will automatically detect seasonality.',
        examples=[False],
    )
    yearly_seasonality: Optional[Any] = Field(
        None,
        description='Should yearly seasonality be applied. An integer value will specify Fourier order of seasonality, `None` will automatically detect seasonality.',
        examples=[False],
    )


class Status(Enum):
    stopped = 'stopped'
    failed = 'failed'
    pending = 'pending'
    running = 'running'
    scheduled = 'scheduled'
    success = 'success'
    timed_out = 'timed_out'


class ChartDataResponseResult(BaseModel):
    annotation_data: Optional[List[Dict[str, str]]] = Field(
        None, description='All requested annotation data'
    )
    applied_filters: Optional[List[Dict[str, Any]]] = Field(
        None, description='A list with applied filters'
    )
    cache_key: str = Field(..., description='Unique cache key for query object')
    cache_timeout: int = Field(
        ...,
        description='Cache timeout in following order: custom timeout, datasource timeout, default config timeout.',
    )
    cached_dttm: str = Field(..., description='Cache timestamp')
    data: Optional[List[Dict[str, Any]]] = Field(
        None, description='A list with results'
    )
    error: Optional[str] = Field(None, description='Error')
    is_cached: bool = Field(..., description='Is the result cached')
    query: str = Field(..., description='The executed query statement')
    rejected_filters: Optional[List[Dict[str, Any]]] = Field(
        None, description='A list with rejected filters'
    )
    rowcount: Optional[int] = Field(None, description='Amount of rows in result set')
    stacktrace: Optional[str] = None
    status: Optional[Status] = Field(None, description='Status of the query')


class ChartDataResponseSchema(BaseModel):
    result: Optional[List[ChartDataResponseResult]] = Field(
        None,
        description='A list of results for each corresponding query in the request.',
    )


class RollingType(Enum):
    average = 'average'
    argmin = 'argmin'
    argmax = 'argmax'
    cumsum = 'cumsum'
    cumprod = 'cumprod'
    max = 'max'
    mean = 'mean'
    median = 'median'
    nansum = 'nansum'
    nanmin = 'nanmin'
    nanmax = 'nanmax'
    nanmean = 'nanmean'
    nanmedian = 'nanmedian'
    nanpercentile = 'nanpercentile'
    min = 'min'
    percentile = 'percentile'
    prod = 'prod'
    product = 'product'
    std = 'std'
    sum = 'sum'
    var = 'var'


class WinType(Enum):
    boxcar = 'boxcar'
    triang = 'triang'
    blackman = 'blackman'
    hamming = 'hamming'
    bartlett = 'bartlett'
    parzen = 'parzen'
    bohman = 'bohman'
    blackmanharris = 'blackmanharris'
    nuttall = 'nuttall'
    barthann = 'barthann'
    kaiser = 'kaiser'
    gaussian = 'gaussian'
    general_gaussian = 'general_gaussian'
    slepian = 'slepian'
    exponential = 'exponential'


class ChartDataRollingOptionsSchema(BaseModel):
    center: Optional[bool] = Field(
        None,
        description='Should the label be at the center of the window. Default: `false`',
        examples=[False],
    )
    min_periods: Optional[int] = Field(
        None,
        description='The minimum amount of periods required for a row to be included in the result set.',
        examples=[7],
    )
    rolling_type: RollingType = Field(
        ...,
        description='Type of rolling window. Any numpy function will work.',
        examples=['percentile'],
    )
    rolling_type_options: Optional[Dict[str, Any]] = Field(None, examples=[{}])
    win_type: Optional[WinType] = Field(
        None,
        description='Type of window function. See [SciPy window functions](https://docs.scipy.org/doc/scipy/reference/signal.windows.html#module-scipy.signal.windows) for more details. Some window functions require passing additional parameters to `rolling_type_options`. For instance, to use `gaussian`, the parameter `std` needs to be provided.',
    )
    window: int = Field(
        ..., description='Size of the rolling window in days.', examples=[7]
    )


class ChartDataSelectOptionsSchema(BaseModel):
    columns: Optional[List[str]] = Field(
        None,
        description='Columns which to select from the input data, in the desired order. If columns are renamed, the original column name should be referenced here.',
        examples=[['country', 'gender', 'age']],
    )
    exclude: Optional[List[str]] = Field(
        None,
        description='Columns to exclude from selection.',
        examples=[['my_temp_column']],
    )
    rename: Optional[List[Dict[str, Any]]] = Field(
        None,
        description="columns which to rename, mapping source column to target column. For instance, `{'y': 'y2'}` will rename the column `y` to `y2`.",
        examples=[[{'age': 'average_age'}]],
    )


class ChartDataSortOptionsSchema(BaseModel):
    aggregates: Optional[Dict[str, Any]] = Field(
        None,
        description='The keys are the name of the aggregate column to be created, and the values specify the details of how to apply the aggregation. If an operator requires additional options, these can be passed here to be unpacked in the operator call. The following numpy operators are supported: average, argmin, argmax, cumsum, cumprod, max, mean, median, nansum, nanmin, nanmax, nanmean, nanmedian, min, percentile, prod, product, std, sum, var. Any options required by the operator can be passed to the `options` object.\n\nIn the example, a new column `first_quantile` is created based on values in the column `my_col` using the `percentile` operator with the `q=0.25` parameter.',
        examples=[
            {
                'first_quantile': {
                    'column': 'my_col',
                    'operator': 'percentile',
                    'options': {'q': 0.25},
                }
            }
        ],
    )
    columns: Dict[str, Any] = Field(
        ...,
        description='columns by by which to sort. The key specifies the column name, value specifies if sorting in ascending order.',
        examples=[{'country': True, 'gender': False}],
    )


class ChartEntityResponseSchema(BaseModel):
    cache_timeout: Optional[int] = Field(
        None,
        description='Duration (in seconds) of the caching timeout for this chart. Note this defaults to the datasource/table timeout if undefined.',
    )
    changed_on: Optional[str] = Field(
        None, description='The ISO date that the chart was last changed.'
    )
    datasource: Optional[str] = Field(None, description='The datasource name.')
    description: Optional[str] = Field(
        None, description='A description of the chart propose.'
    )
    description_markeddown: Optional[str] = Field(
        None, description='Sanitized HTML version of the chart description.'
    )
    form_data: Optional[Dict[str, Any]] = Field(
        None,
        description="Form data from the Explore controls used to form the chart's data query.",
    )
    modified: Optional[str] = None
    slice_id: Optional[int] = None
    slice_name: Optional[str] = Field(None, description='The name of the chart.')
    slice_url: Optional[str] = Field(None, description='The URL of the chart.')


class ChartFavStarResponseResult(BaseModel):
    id: Optional[int] = Field(None, description='The Chart id')
    value: Optional[bool] = Field(None, description='The FaveStar value')


class ChartGetDatasourceObjectDataResponse(BaseModel):
    datasource_id: Optional[int] = Field(None, description='The datasource identifier')
    datasource_type: Optional[int] = Field(None, description='The datasource type')


class ChartGetDatasourceObjectResponse(BaseModel):
    label: Optional[str] = Field(None, description='The name of the datasource')
    value: Optional[ChartGetDatasourceObjectDataResponse] = None


class ChartGetDatasourceResponseSchema(BaseModel):
    count: Optional[int] = Field(None, description='The total number of datasources')
    result: Optional[ChartGetDatasourceObjectResponse] = None


class DatasourceType(Enum):
    druid = 'druid'
    table = 'table'
    view = 'view'


class ChartRestApiPost(BaseModel):
    cache_timeout: Optional[int] = Field(
        None,
        description='Duration (in seconds) of the caching timeout for this chart. Note this defaults to the datasource/table timeout if undefined.',
    )
    dashboards: Optional[List[int]] = None
    datasource_id: int = Field(
        ...,
        description='The id of the dataset/datasource this new chart will use. A complete datasource identification needs `datasouce_id` and `datasource_type`.',
    )
    datasource_name: Optional[str] = Field(None, description='The datasource name.')
    datasource_type: DatasourceType = Field(
        ..., description='The type of dataset/datasource identified on `datasource_id`.'
    )
    description: Optional[str] = Field(
        None, description='A description of the chart propose.'
    )
    owners: Optional[List[int]] = None
    params: Optional[str] = Field(
        None,
        description='Parameters are generated dynamically when clicking the save or overwrite button in the explore view. This JSON object for power users who may want to alter specific parameters.',
    )
    query_context: Optional[str] = Field(
        None,
        description='The query context represents the queries that need to run in order to generate the data the visualization, and in what format the data should be returned.',
    )
    slice_name: constr(min_length=1, max_length=250) = Field(
        ..., description='The name of the chart.'
    )
    viz_type: Optional[constr(min_length=0, max_length=250)] = Field(
        None,
        description='The type of chart visualization used.',
        examples=[['bar', 'line_multi', 'area', 'table']],
    )


class ChartRestApiPut(BaseModel):
    cache_timeout: Optional[int] = Field(
        None,
        description='Duration (in seconds) of the caching timeout for this chart. Note this defaults to the datasource/table timeout if undefined.',
    )
    dashboards: Optional[List[int]] = None
    datasource_id: Optional[int] = Field(
        None,
        description='The id of the dataset/datasource this new chart will use. A complete datasource identification needs `datasouce_id` and `datasource_type`.',
    )
    datasource_type: Optional[DatasourceType] = Field(
        None,
        description='The type of dataset/datasource identified on `datasource_id`.',
    )
    description: Optional[str] = Field(
        None, description='A description of the chart propose.'
    )
    owners: Optional[List[int]] = None
    params: Optional[str] = Field(
        None,
        description='Parameters are generated dynamically when clicking the save or overwrite button in the explore view. This JSON object for power users who may want to alter specific parameters.',
    )
    query_context: Optional[str] = Field(
        None,
        description='The query context represents the queries that need to run in order to generate the data the visualization, and in what format the data should be returned.',
    )
    slice_name: Optional[constr(min_length=0, max_length=250)] = Field(
        None, description='The name of the chart.'
    )
    viz_type: Optional[constr(min_length=0, max_length=250)] = Field(
        None,
        description='The type of chart visualization used.',
        examples=[['bar', 'line_multi', 'area', 'table']],
    )


class CssTemplateRestApiPost(BaseModel):
    css: Optional[str] = None
    template_name: Optional[constr(max_length=250)] = None


class CssTemplateRestApiPut(BaseModel):
    css: Optional[str] = None
    template_name: Optional[constr(max_length=250)] = None


class DashboardRestApiGet(BaseModel):
    id: Optional[int] = None


class DashboardRestApiPost(BaseModel):
    css: Optional[str] = None
    dashboard_title: Optional[constr(min_length=0, max_length=500)] = Field(
        None, description='A title for the dashboard.'
    )
    json_metadata: Optional[str] = Field(
        None,
        description='This JSON object is generated dynamically when clicking the save or overwrite button in the dashboard view. It is exposed here for reference and for power users who may want to alter  specific parameters.',
    )
    owners: Optional[List[int]] = None
    position_json: Optional[str] = Field(
        None,
        description='This json object describes the positioning of the widgets in the dashboard. It is dynamically generated when adjusting the widgets size and positions by using drag & drop in the dashboard view',
    )
    published: Optional[bool] = Field(
        None,
        description='Determines whether or not this dashboard is visible in the list of all dashboards.',
    )
    roles: Optional[List[int]] = None
    slug: Optional[constr(min_length=1, max_length=255)] = Field(
        None,
        description='Unique identifying part for the web address of the dashboard.',
    )


class DashboardRestApiPut(BaseModel):
    css: Optional[str] = Field(None, description='Override CSS for the dashboard.')
    dashboard_title: Optional[constr(min_length=0, max_length=500)] = Field(
        None, description='A title for the dashboard.'
    )
    json_metadata: Optional[str] = Field(
        None,
        description='This JSON object is generated dynamically when clicking the save or overwrite button in the dashboard view. It is exposed here for reference and for power users who may want to alter  specific parameters.',
    )
    owners: Optional[List[int]] = None
    position_json: Optional[str] = Field(
        None,
        description='This json object describes the positioning of the widgets in the dashboard. It is dynamically generated when adjusting the widgets size and positions by using drag & drop in the dashboard view',
    )
    published: Optional[bool] = Field(
        None,
        description='Determines whether or not this dashboard is visible in the list of all dashboards.',
    )
    roles: Optional[List[int]] = None
    slug: Optional[constr(min_length=0, max_length=255)] = Field(
        None,
        description='Unique identifying part for the web address of the dashboard.',
    )


class Database(BaseModel):
    allow_multi_schema_metadata_fetch: Optional[bool] = None
    allows_cost_estimate: Optional[bool] = None
    allows_subquery: Optional[bool] = None
    allows_virtual_table_explore: Optional[bool] = None
    backend: Optional[str] = None
    explore_database_id: Optional[int] = None
    id: Optional[int] = None
    name: Optional[str] = None


class DatabaseFunctionNamesResponse(BaseModel):
    function_names: Optional[List[str]] = None


class DatabaseRelatedChart(BaseModel):
    id: Optional[int] = None
    slice_name: Optional[str] = None
    viz_type: Optional[str] = None


class DatabaseRelatedCharts(BaseModel):
    count: Optional[int] = Field(None, description='Chart count')
    result: Optional[List[DatabaseRelatedChart]] = Field(
        None, description='A list of dashboards'
    )


class DatabaseRelatedDashboard(BaseModel):
    id: Optional[int] = None
    json_metadata: Optional[Dict[str, Any]] = None
    slug: Optional[str] = None
    title: Optional[str] = None


class DatabaseRelatedDashboards(BaseModel):
    count: Optional[int] = Field(None, description='Dashboard count')
    result: Optional[List[DatabaseRelatedDashboard]] = Field(
        None, description='A list of dashboards'
    )


class DatabaseRelatedObjectsResponse(BaseModel):
    charts: Optional[DatabaseRelatedCharts] = None
    dashboards: Optional[DatabaseRelatedDashboards] = None


class DatabaseRestApiGet(BaseModel):
    allow_csv_upload: Optional[bool] = None
    allow_ctas: Optional[bool] = None
    allow_cvas: Optional[bool] = None
    allow_dml: Optional[bool] = None
    allow_multi_schema_metadata_fetch: Optional[bool] = None
    allow_run_async: Optional[bool] = None
    backend: Optional[Any] = None
    cache_timeout: Optional[int] = None
    configuration_method: Optional[constr(max_length=255)] = None
    database_name: constr(max_length=250)
    encrypted_extra: Optional[str] = None
    expose_in_sqllab: Optional[bool] = None
    extra: Optional[str] = None
    force_ctas_schema: Optional[constr(max_length=250)] = None
    id: Optional[int] = None
    impersonate_user: Optional[bool] = None
    parameters: Optional[Any] = None
    server_cert: Optional[str] = None
    sqlalchemy_uri: constr(max_length=1024)


class DatabaseRestApiPost(BaseModel):
    allow_csv_upload: Optional[bool] = Field(
        None,
        description='Allow to upload CSV file data into this databaseIf selected, please set the schemas allowed for csv upload in Extra.',
    )
    allow_ctas: Optional[bool] = Field(
        None, description='Allow CREATE TABLE AS option in SQL Lab'
    )
    allow_cvas: Optional[bool] = Field(
        None, description='Allow CREATE VIEW AS option in SQL Lab'
    )
    allow_dml: Optional[bool] = Field(
        None,
        description='Allow users to run non-SELECT statements (UPDATE, DELETE, CREATE, ...) in SQL Lab',
    )
    allow_multi_schema_metadata_fetch: Optional[bool] = Field(
        None,
        description='Allow SQL Lab to fetch a list of all tables and all views across all database schemas. For large data warehouse with thousands of tables, this can be expensive and put strain on the system.',
    )
    allow_run_async: Optional[bool] = Field(
        None,
        description='Operate the database in asynchronous mode, meaning  that the queries are executed on remote workers as opposed to on the web server itself. This assumes that you have a Celery worker setup as well as a results backend. Refer to the installation docs for more information.',
    )
    cache_timeout: Optional[int] = Field(
        None,
        description='Duration (in seconds) of the caching timeout for charts of this database. A timeout of 0 indicates that the cache never expires. Note this defaults to the global timeout if undefined.',
    )
    configuration_method: Optional[Any] = Field(
        'sqlalchemy_form',
        description='Configuration_method is used on the frontend to inform the backend whether to explode parameters or to provide only a sqlalchemy_uri.',
    )
    database_name: constr(min_length=1, max_length=250) = Field(
        ..., description='A database name to identify this connection.'
    )
    encrypted_extra: Optional[str] = Field(
        None,
        description='<p>JSON string containing additional connection configuration.<br>This is used to provide connection information for systems like Hive, Presto, and BigQuery, which do not conform to the username:password syntax normally used by SQLAlchemy.</p>',
    )
    engine: Optional[str] = Field(None, description='SQLAlchemy engine to use')
    expose_in_sqllab: Optional[bool] = Field(
        None, description='Expose this database to SQLLab'
    )
    extra: Optional[str] = Field(
        None,
        description='<p>JSON string containing extra configuration elements.<br>1. The <code>engine_params</code> object gets unpacked into the <a href="https://docs.sqlalchemy.org/en/latest/core/engines.html#sqlalchemy.create_engine">sqlalchemy.create_engine</a> call, while the <code>metadata_params</code> gets unpacked into the <a href="https://docs.sqlalchemy.org/en/rel_1_0/core/metadata.html#sqlalchemy.schema.MetaData">sqlalchemy.MetaData</a> call.<br>2. The <code>metadata_cache_timeout</code> is a cache timeout setting in seconds for metadata fetch of this database. Specify it as <strong>"metadata_cache_timeout": {"schema_cache_timeout": 600, "table_cache_timeout": 600}</strong>. If unset, cache will not be enabled for the functionality. A timeout of 0 indicates that the cache never expires.<br>3. The <code>schemas_allowed_for_csv_upload</code> is a comma separated list of schemas that CSVs are allowed to upload to. Specify it as <strong>"schemas_allowed_for_csv_upload": ["public", "csv_upload"]</strong>. If database flavor does not support schema or any schema is allowed to be accessed, just leave the list empty<br>4. the <code>version</code> field is a string specifying the this db\'s version. This should be used with Presto DBs so that the syntax is correct<br>5. The <code>allows_virtual_table_explore</code> field is a boolean specifying whether or not the Explore button in SQL Lab results is shown.</p>',
    )
    force_ctas_schema: Optional[constr(min_length=0, max_length=250)] = Field(
        None,
        description='When allowing CREATE TABLE AS option in SQL Lab, this option forces the table to be created in this schema',
    )
    impersonate_user: Optional[bool] = Field(
        None,
        description='If Presto, all the queries in SQL Lab are going to be executed as the currently logged on user who must have permission to run them.<br/>If Hive and hive.server2.enable.doAs is enabled, will run the queries as service account, but impersonate the currently logged on user via hive.server2.proxy.user property.',
    )
    parameters: Optional[Dict[str, Any]] = Field(
        None, description='DB-specific parameters for configuration'
    )
    server_cert: Optional[str] = Field(
        None,
        description='<p>Optional CA_BUNDLE contents to validate HTTPS requests. Only available on certain database engines.</p>',
    )
    sqlalchemy_uri: Optional[constr(min_length=1, max_length=1024)] = Field(
        None,
        description='<p>Refer to the <a href="https://docs.sqlalchemy.org/en/rel_1_2/core/engines.html#database-urls">SqlAlchemy docs</a> for more information on how to structure your URI.</p>',
    )


class DatabaseRestApiPut(BaseModel):
    allow_csv_upload: Optional[bool] = Field(
        None,
        description='Allow to upload CSV file data into this databaseIf selected, please set the schemas allowed for csv upload in Extra.',
    )
    allow_ctas: Optional[bool] = Field(
        None, description='Allow CREATE TABLE AS option in SQL Lab'
    )
    allow_cvas: Optional[bool] = Field(
        None, description='Allow CREATE VIEW AS option in SQL Lab'
    )
    allow_dml: Optional[bool] = Field(
        None,
        description='Allow users to run non-SELECT statements (UPDATE, DELETE, CREATE, ...) in SQL Lab',
    )
    allow_multi_schema_metadata_fetch: Optional[bool] = Field(
        None,
        description='Allow SQL Lab to fetch a list of all tables and all views across all database schemas. For large data warehouse with thousands of tables, this can be expensive and put strain on the system.',
    )
    allow_run_async: Optional[bool] = Field(
        None,
        description='Operate the database in asynchronous mode, meaning  that the queries are executed on remote workers as opposed to on the web server itself. This assumes that you have a Celery worker setup as well as a results backend. Refer to the installation docs for more information.',
    )
    cache_timeout: Optional[int] = Field(
        None,
        description='Duration (in seconds) of the caching timeout for charts of this database. A timeout of 0 indicates that the cache never expires. Note this defaults to the global timeout if undefined.',
    )
    configuration_method: Optional[Any] = Field(
        'sqlalchemy_form',
        description='Configuration_method is used on the frontend to inform the backend whether to explode parameters or to provide only a sqlalchemy_uri.',
    )
    database_name: Optional[constr(min_length=1, max_length=250)] = Field(
        None, description='A database name to identify this connection.'
    )
    encrypted_extra: Optional[str] = Field(
        None,
        description='<p>JSON string containing additional connection configuration.<br>This is used to provide connection information for systems like Hive, Presto, and BigQuery, which do not conform to the username:password syntax normally used by SQLAlchemy.</p>',
    )
    engine: Optional[str] = Field(None, description='SQLAlchemy engine to use')
    expose_in_sqllab: Optional[bool] = Field(
        None, description='Expose this database to SQLLab'
    )
    extra: Optional[str] = Field(
        None,
        description='<p>JSON string containing extra configuration elements.<br>1. The <code>engine_params</code> object gets unpacked into the <a href="https://docs.sqlalchemy.org/en/latest/core/engines.html#sqlalchemy.create_engine">sqlalchemy.create_engine</a> call, while the <code>metadata_params</code> gets unpacked into the <a href="https://docs.sqlalchemy.org/en/rel_1_0/core/metadata.html#sqlalchemy.schema.MetaData">sqlalchemy.MetaData</a> call.<br>2. The <code>metadata_cache_timeout</code> is a cache timeout setting in seconds for metadata fetch of this database. Specify it as <strong>"metadata_cache_timeout": {"schema_cache_timeout": 600, "table_cache_timeout": 600}</strong>. If unset, cache will not be enabled for the functionality. A timeout of 0 indicates that the cache never expires.<br>3. The <code>schemas_allowed_for_csv_upload</code> is a comma separated list of schemas that CSVs are allowed to upload to. Specify it as <strong>"schemas_allowed_for_csv_upload": ["public", "csv_upload"]</strong>. If database flavor does not support schema or any schema is allowed to be accessed, just leave the list empty<br>4. the <code>version</code> field is a string specifying the this db\'s version. This should be used with Presto DBs so that the syntax is correct<br>5. The <code>allows_virtual_table_explore</code> field is a boolean specifying whether or not the Explore button in SQL Lab results is shown.</p>',
    )
    force_ctas_schema: Optional[constr(min_length=0, max_length=250)] = Field(
        None,
        description='When allowing CREATE TABLE AS option in SQL Lab, this option forces the table to be created in this schema',
    )
    impersonate_user: Optional[bool] = Field(
        None,
        description='If Presto, all the queries in SQL Lab are going to be executed as the currently logged on user who must have permission to run them.<br/>If Hive and hive.server2.enable.doAs is enabled, will run the queries as service account, but impersonate the currently logged on user via hive.server2.proxy.user property.',
    )
    parameters: Optional[Dict[str, Any]] = Field(
        None, description='DB-specific parameters for configuration'
    )
    server_cert: Optional[str] = Field(
        None,
        description='<p>Optional CA_BUNDLE contents to validate HTTPS requests. Only available on certain database engines.</p>',
    )
    sqlalchemy_uri: Optional[constr(min_length=0, max_length=1024)] = Field(
        None,
        description='<p>Refer to the <a href="https://docs.sqlalchemy.org/en/rel_1_2/core/engines.html#database-urls">SqlAlchemy docs</a> for more information on how to structure your URI.</p>',
    )


class DatabaseTestConnectionSchema(BaseModel):
    configuration_method: Optional[Any] = Field(
        'sqlalchemy_form',
        description='Configuration_method is used on the frontend to inform the backend whether to explode parameters or to provide only a sqlalchemy_uri.',
    )
    database_name: Optional[constr(min_length=1, max_length=250)] = Field(
        None, description='A database name to identify this connection.'
    )
    encrypted_extra: Optional[str] = Field(
        None,
        description='<p>JSON string containing additional connection configuration.<br>This is used to provide connection information for systems like Hive, Presto, and BigQuery, which do not conform to the username:password syntax normally used by SQLAlchemy.</p>',
    )
    engine: Optional[str] = Field(None, description='SQLAlchemy engine to use')
    extra: Optional[str] = Field(
        None,
        description='<p>JSON string containing extra configuration elements.<br>1. The <code>engine_params</code> object gets unpacked into the <a href="https://docs.sqlalchemy.org/en/latest/core/engines.html#sqlalchemy.create_engine">sqlalchemy.create_engine</a> call, while the <code>metadata_params</code> gets unpacked into the <a href="https://docs.sqlalchemy.org/en/rel_1_0/core/metadata.html#sqlalchemy.schema.MetaData">sqlalchemy.MetaData</a> call.<br>2. The <code>metadata_cache_timeout</code> is a cache timeout setting in seconds for metadata fetch of this database. Specify it as <strong>"metadata_cache_timeout": {"schema_cache_timeout": 600, "table_cache_timeout": 600}</strong>. If unset, cache will not be enabled for the functionality. A timeout of 0 indicates that the cache never expires.<br>3. The <code>schemas_allowed_for_csv_upload</code> is a comma separated list of schemas that CSVs are allowed to upload to. Specify it as <strong>"schemas_allowed_for_csv_upload": ["public", "csv_upload"]</strong>. If database flavor does not support schema or any schema is allowed to be accessed, just leave the list empty<br>4. the <code>version</code> field is a string specifying the this db\'s version. This should be used with Presto DBs so that the syntax is correct<br>5. The <code>allows_virtual_table_explore</code> field is a boolean specifying whether or not the Explore button in SQL Lab results is shown.</p>',
    )
    impersonate_user: Optional[bool] = Field(
        None,
        description='If Presto, all the queries in SQL Lab are going to be executed as the currently logged on user who must have permission to run them.<br/>If Hive and hive.server2.enable.doAs is enabled, will run the queries as service account, but impersonate the currently logged on user via hive.server2.proxy.user property.',
    )
    parameters: Optional[Dict[str, Any]] = Field(
        None, description='DB-specific parameters for configuration'
    )
    server_cert: Optional[str] = Field(
        None,
        description='<p>Optional CA_BUNDLE contents to validate HTTPS requests. Only available on certain database engines.</p>',
    )
    sqlalchemy_uri: Optional[constr(min_length=1, max_length=1024)] = Field(
        None,
        description='<p>Refer to the <a href="https://docs.sqlalchemy.org/en/rel_1_2/core/engines.html#database-urls">SqlAlchemy docs</a> for more information on how to structure your URI.</p>',
    )


class DatabaseValidateParametersSchema(BaseModel):
    configuration_method: Any = Field(
        ...,
        description='Configuration_method is used on the frontend to inform the backend whether to explode parameters or to provide only a sqlalchemy_uri.',
    )
    database_name: Optional[constr(min_length=1, max_length=250)] = Field(
        None, description='A database name to identify this connection.'
    )
    encrypted_extra: Optional[str] = Field(
        None,
        description='<p>JSON string containing additional connection configuration.<br>This is used to provide connection information for systems like Hive, Presto, and BigQuery, which do not conform to the username:password syntax normally used by SQLAlchemy.</p>',
    )
    engine: str = Field(..., description='SQLAlchemy engine to use')
    extra: Optional[str] = Field(
        None,
        description='<p>JSON string containing extra configuration elements.<br>1. The <code>engine_params</code> object gets unpacked into the <a href="https://docs.sqlalchemy.org/en/latest/core/engines.html#sqlalchemy.create_engine">sqlalchemy.create_engine</a> call, while the <code>metadata_params</code> gets unpacked into the <a href="https://docs.sqlalchemy.org/en/rel_1_0/core/metadata.html#sqlalchemy.schema.MetaData">sqlalchemy.MetaData</a> call.<br>2. The <code>metadata_cache_timeout</code> is a cache timeout setting in seconds for metadata fetch of this database. Specify it as <strong>"metadata_cache_timeout": {"schema_cache_timeout": 600, "table_cache_timeout": 600}</strong>. If unset, cache will not be enabled for the functionality. A timeout of 0 indicates that the cache never expires.<br>3. The <code>schemas_allowed_for_csv_upload</code> is a comma separated list of schemas that CSVs are allowed to upload to. Specify it as <strong>"schemas_allowed_for_csv_upload": ["public", "csv_upload"]</strong>. If database flavor does not support schema or any schema is allowed to be accessed, just leave the list empty<br>4. the <code>version</code> field is a string specifying the this db\'s version. This should be used with Presto DBs so that the syntax is correct<br>5. The <code>allows_virtual_table_explore</code> field is a boolean specifying whether or not the Explore button in SQL Lab results is shown.</p>',
    )
    impersonate_user: Optional[bool] = Field(
        None,
        description='If Presto, all the queries in SQL Lab are going to be executed as the currently logged on user who must have permission to run them.<br/>If Hive and hive.server2.enable.doAs is enabled, will run the queries as service account, but impersonate the currently logged on user via hive.server2.proxy.user property.',
    )
    parameters: Optional[Dict[str, Any]] = Field(
        None, description='DB-specific parameters for configuration'
    )
    server_cert: Optional[str] = Field(
        None,
        description='<p>Optional CA_BUNDLE contents to validate HTTPS requests. Only available on certain database engines.</p>',
    )


class DatasetColumnsPut(BaseModel):
    column_name: constr(min_length=1, max_length=255)
    description: Optional[str] = None
    expression: Optional[str] = None
    filterable: Optional[bool] = None
    groupby: Optional[bool] = None
    id: Optional[int] = None
    is_active: Optional[bool] = None
    is_dttm: Optional[bool] = None
    python_date_format: Optional[constr(min_length=1, max_length=255)] = None
    type: Optional[constr(min_length=1, max_length=32)] = None
    uuid: Optional[str] = None
    verbose_name: Optional[str] = None


class DatasetColumnsRestApiGet(BaseModel):
    id: Optional[int] = None


class DatasetColumnsRestApiGetList(BaseModel):
    id: Optional[int] = None


class DatasetColumnsRestApiPost(BaseModel):
    id: Optional[int] = None


class DatasetColumnsRestApiPut(BaseModel):
    id: Optional[int] = None


class DatasetMetricRestApiGet(BaseModel):
    id: Optional[int] = None


class DatasetMetricRestApiGetList(BaseModel):
    id: Optional[int] = None


class DatasetMetricRestApiPost(BaseModel):
    id: Optional[int] = None


class DatasetMetricRestApiPut(BaseModel):
    id: Optional[int] = None


class DatasetMetricsPut(BaseModel):
    d3format: Optional[constr(min_length=1, max_length=128)] = None
    description: Optional[str] = None
    expression: str
    id: Optional[int] = None
    metric_name: constr(min_length=1, max_length=255)
    metric_type: Optional[constr(min_length=1, max_length=32)] = None
    warning_text: Optional[str] = None


class DatasetRelatedChart(BaseModel):
    id: Optional[int] = None
    slice_name: Optional[str] = None
    viz_type: Optional[str] = None


class DatasetRelatedCharts(BaseModel):
    count: Optional[int] = Field(None, description='Chart count')
    result: Optional[List[DatasetRelatedChart]] = Field(
        None, description='A list of dashboards'
    )


class DatasetRelatedDashboard(BaseModel):
    id: Optional[int] = None
    json_metadata: Optional[Dict[str, Any]] = None
    slug: Optional[str] = None
    title: Optional[str] = None


class DatasetRelatedDashboards(BaseModel):
    count: Optional[int] = Field(None, description='Dashboard count')
    result: Optional[List[DatasetRelatedDashboard]] = Field(
        None, description='A list of dashboards'
    )


class DatasetRelatedObjectsResponse(BaseModel):
    charts: Optional[DatasetRelatedCharts] = None
    dashboards: Optional[DatasetRelatedDashboards] = None


class DatasetRestApiPost(BaseModel):
    database: int
    owners: Optional[List[int]] = None
    schema_: Optional[constr(min_length=0, max_length=250)] = Field(
        None, alias='schema'
    )
    table_name: constr(min_length=1, max_length=250)


class DatasetRestApiPut(BaseModel):
    cache_timeout: Optional[int] = None
    columns: Optional[List[DatasetColumnsPut]] = None
    database_id: Optional[int] = None
    default_endpoint: Optional[str] = None
    description: Optional[str] = None
    extra: Optional[str] = None
    fetch_values_predicate: Optional[constr(min_length=0, max_length=1000)] = None
    filter_select_enabled: Optional[bool] = None
    is_sqllab_view: Optional[bool] = None
    main_dttm_col: Optional[str] = None
    metrics: Optional[List[DatasetMetricsPut]] = None
    offset: Optional[int] = None
    owners: Optional[List[int]] = None
    schema_: Optional[constr(min_length=0, max_length=255)] = Field(
        None, alias='schema'
    )
    sql: Optional[str] = None
    table_name: Optional[constr(min_length=1, max_length=250)] = None
    template_params: Optional[str] = None


class Datasource(BaseModel):
    database_name: Optional[str] = Field(None, description='Datasource name')
    datasource_name: Optional[str] = Field(None, description='The datasource name.')
    datasource_type: DatasourceType = Field(
        ..., description='The type of dataset/datasource identified on `datasource_id`.'
    )
    schema_: Optional[str] = Field(
        None, alias='schema', description='Datasource schema'
    )


class DistinctResultResponse(BaseModel):
    text: Optional[str] = Field(None, description='The distinct item')


class GetFavStarIdsSchema(BaseModel):
    result: Optional[List[ChartFavStarResponseResult]] = Field(
        None,
        description='A list of results for each corresponding chart in the request',
    )


class LogRestApiPost(BaseModel):
    id: Optional[int] = None


class LogRestApiPut(BaseModel):
    action: Optional[constr(max_length=512)] = None
    dttm: Optional[datetime] = None
    json_: Optional[str] = Field(None, alias='json')
    user: Optional[Any] = None


class Meta(BaseModel):
    first_name: constr(max_length=64)
    id: Optional[int] = None


class Meta1(BaseModel):
    first_name: constr(max_length=64)
    id: Optional[int] = None


class Meta10(BaseModel):
    first_name: constr(max_length=64)
    id: Optional[int] = None
    last_name: constr(max_length=64)
    username: constr(max_length=64)


class Meta11(BaseModel):
    first_name: constr(max_length=64)
    id: Optional[int] = None
    last_name: constr(max_length=64)


class Meta12(BaseModel):
    active: Optional[bool] = None
    changed_on: Optional[datetime] = None
    created_on: Optional[datetime] = None
    email: constr(max_length=64)
    fail_login_count: Optional[int] = None
    first_name: constr(max_length=64)
    id: Optional[int] = None
    last_login: Optional[datetime] = None
    last_name: constr(max_length=64)
    login_count: Optional[int] = None
    password: Optional[constr(max_length=256)] = None
    username: constr(max_length=64)


class Meta13(BaseModel):
    first_name: constr(max_length=64)
    id: Optional[int] = None
    last_name: constr(max_length=64)


class Meta14(BaseModel):
    first_name: constr(max_length=64)
    id: Optional[int] = None
    last_name: constr(max_length=64)


class Meta15(BaseModel):
    first_name: constr(max_length=64)
    id: Optional[int] = None
    last_name: constr(max_length=64)
    username: constr(max_length=64)


class Meta16(BaseModel):
    id: Optional[int] = None
    name: constr(max_length=64)


class Meta17(BaseModel):
    first_name: constr(max_length=64)
    id: Optional[int] = None
    last_name: constr(max_length=64)
    username: constr(max_length=64)


class Meta18(BaseModel):
    first_name: constr(max_length=64)
    last_name: constr(max_length=64)


class Meta19(BaseModel):
    first_name: constr(max_length=64)
    username: constr(max_length=64)


class Meta2(BaseModel):
    id: Optional[int] = None
    name: Optional[constr(max_length=250)] = None


class Meta20(BaseModel):
    first_name: constr(max_length=64)
    id: Optional[int] = None
    last_name: constr(max_length=64)
    username: constr(max_length=64)


class Meta21(BaseModel):
    database_name: constr(max_length=250)
    id: Optional[int] = None


class Meta22(BaseModel):
    changed_on: Optional[datetime] = None
    column_name: constr(max_length=255)
    created_on: Optional[datetime] = None
    description: Optional[str] = None
    expression: Optional[str] = None
    filterable: Optional[bool] = None
    groupby: Optional[bool] = None
    id: Optional[int] = None
    is_active: Optional[bool] = None
    is_dttm: Optional[bool] = None
    python_date_format: Optional[constr(max_length=255)] = None
    type: Optional[constr(max_length=32)] = None
    type_generic: Optional[Any] = None
    uuid: Optional[UUID] = None
    verbose_name: Optional[constr(max_length=1024)] = None


class Meta23(BaseModel):
    database_name: constr(max_length=250)
    id: Optional[int] = None


class Meta24(BaseModel):
    first_name: constr(max_length=64)
    id: Optional[int] = None
    last_name: constr(max_length=64)
    username: constr(max_length=64)


class Meta25(BaseModel):
    changed_on: Optional[datetime] = None
    created_on: Optional[datetime] = None
    d3format: Optional[constr(max_length=128)] = None
    description: Optional[str] = None
    expression: str
    extra: Optional[str] = None
    id: Optional[int] = None
    metric_name: constr(max_length=255)
    metric_type: Optional[constr(max_length=32)] = None
    uuid: Optional[UUID] = None
    verbose_name: Optional[constr(max_length=1024)] = None
    warning_text: Optional[str] = None


class Meta26(BaseModel):
    first_name: constr(max_length=64)
    id: Optional[int] = None
    last_name: constr(max_length=64)
    username: constr(max_length=64)


class Meta27(BaseModel):
    database_name: constr(max_length=250)


class Meta28(BaseModel):
    id: Optional[int] = None


class Meta29(BaseModel):
    first_name: constr(max_length=64)
    id: Optional[int] = None
    last_name: constr(max_length=64)


class Meta3(BaseModel):
    first_name: constr(max_length=64)
    last_name: constr(max_length=64)


class Meta30(BaseModel):
    database_name: constr(max_length=250)
    id: Optional[int] = None


class Meta31(BaseModel):
    first_name: constr(max_length=64)
    id: Optional[int] = None
    last_name: constr(max_length=64)


class Meta32(BaseModel):
    database_name: constr(max_length=250)
    id: Optional[int] = None


class Meta33(BaseModel):
    first_name: constr(max_length=64)
    last_name: constr(max_length=64)


class Meta34(BaseModel):
    first_name: constr(max_length=64)
    last_name: constr(max_length=64)


class Meta35(BaseModel):
    id: Optional[int] = None
    type: constr(max_length=50)


class Meta36(BaseModel):
    first_name: constr(max_length=64)
    id: Optional[int] = None
    last_name: constr(max_length=64)


class Meta37(BaseModel):
    database_name: constr(max_length=250)
    id: Optional[int] = None


class Meta38(BaseModel):
    id: Optional[int] = None
    recipient_config_json: Optional[str] = None
    type: constr(max_length=50)


class Meta39(BaseModel):
    first_name: constr(max_length=64)
    id: Optional[int] = None
    last_name: constr(max_length=64)


class Meta4(BaseModel):
    first_name: constr(max_length=64)
    last_name: constr(max_length=64)


class Meta40(BaseModel):
    id: Optional[int] = None
    slice_name: Optional[constr(max_length=250)] = None
    viz_type: Optional[constr(max_length=250)] = None


class Meta41(BaseModel):
    dashboard_title: Optional[constr(max_length=500)] = None
    id: Optional[int] = None


class Meta42(BaseModel):
    username: constr(max_length=64)


class Meta43(BaseModel):
    username: constr(max_length=64)


class Meta5(BaseModel):
    first_name: constr(max_length=64)
    id: Optional[int] = None
    last_name: constr(max_length=64)


class Meta6(BaseModel):
    default_endpoint: Optional[str] = None
    table_name: constr(max_length=250)


class Meta7(BaseModel):
    first_name: constr(max_length=64)
    id: Optional[int] = None
    last_name: constr(max_length=64)
    username: constr(max_length=64)


class Meta8(BaseModel):
    first_name: constr(max_length=64)
    last_name: constr(max_length=64)


class Meta9(BaseModel):
    dashboard_title: Optional[constr(max_length=500)] = None
    id: Optional[int] = None


class QueryRestApiGet(BaseModel):
    changed_on: Optional[datetime] = None
    client_id: constr(max_length=11)
    database: Meta28
    end_result_backend_time: Optional[float] = None
    end_time: Optional[float] = None
    error_message: Optional[str] = None
    executed_sql: Optional[str] = None
    id: Optional[int] = None
    limit: Optional[int] = None
    progress: Optional[int] = None
    results_key: Optional[constr(max_length=64)] = None
    rows: Optional[int] = None
    schema_: Optional[constr(max_length=256)] = Field(None, alias='schema')
    select_as_cta: Optional[bool] = None
    select_as_cta_used: Optional[bool] = None
    select_sql: Optional[str] = None
    sql: Optional[str] = None
    sql_editor_id: Optional[constr(max_length=256)] = None
    start_running_time: Optional[float] = None
    start_time: Optional[float] = None
    status: Optional[constr(max_length=16)] = None
    tab_name: Optional[constr(max_length=256)] = None
    tmp_schema_name: Optional[constr(max_length=256)] = None
    tmp_table_name: Optional[constr(max_length=256)] = None
    tracking_url: Optional[str] = None


class QueryRestApiGetList(BaseModel):
    changed_on: Optional[datetime] = None
    database: Meta27
    end_time: Optional[float] = None
    executed_sql: Optional[str] = None
    id: Optional[int] = None
    rows: Optional[int] = None
    schema_: Optional[constr(max_length=256)] = Field(None, alias='schema')
    sql: Optional[str] = None
    sql_tables: Optional[Any] = None
    start_time: Optional[float] = None
    status: Optional[constr(max_length=16)] = None
    tab_name: Optional[constr(max_length=256)] = None
    tmp_table_name: Optional[constr(max_length=256)] = None
    tracking_url: Optional[str] = None
    user: Optional[Meta26] = None


class QueryRestApiPost(BaseModel):
    id: Optional[int] = None


class QueryRestApiPut(BaseModel):
    id: Optional[int] = None


class RelatedResultResponse(BaseModel):
    text: Optional[str] = Field(
        None, description='The related item string representation'
    )
    value: Optional[int] = Field(None, description='The related item identifier')


class ReportExecutionLogRestApiGet(BaseModel):
    end_dttm: Optional[datetime] = None
    error_message: Optional[str] = None
    id: Optional[int] = None
    scheduled_dttm: datetime
    start_dttm: Optional[datetime] = None
    state: constr(max_length=50)
    uuid: Optional[UUID] = None
    value: Optional[float] = None
    value_row_json: Optional[str] = None


class ReportExecutionLogRestApiGetList(BaseModel):
    end_dttm: Optional[datetime] = None
    error_message: Optional[str] = None
    id: Optional[int] = None
    scheduled_dttm: datetime
    start_dttm: Optional[datetime] = None
    state: constr(max_length=50)
    uuid: Optional[UUID] = None
    value: Optional[float] = None
    value_row_json: Optional[str] = None


class ReportExecutionLogRestApiPost(BaseModel):
    id: Optional[int] = None


class ReportExecutionLogRestApiPut(BaseModel):
    id: Optional[int] = None


class Type1(Enum):
    Email = 'Email'
    Slack = 'Slack'


class ReportRecipientConfigJSON(BaseModel):
    target: Optional[str] = None


class ReportScheduleRestApiGet(BaseModel):
    active: Optional[bool] = None
    chart: Optional[Meta40] = None
    context_markdown: Optional[str] = None
    creation_method: Optional[constr(max_length=255)] = None
    crontab: constr(max_length=1000)
    dashboard: Optional[Meta41] = None
    database: Optional[Meta37] = None
    description: Optional[str] = None
    grace_period: Optional[int] = None
    id: Optional[int] = None
    last_eval_dttm: Optional[datetime] = None
    last_state: Optional[constr(max_length=50)] = None
    last_value: Optional[float] = None
    last_value_row_json: Optional[str] = None
    log_retention: Optional[int] = None
    name: constr(max_length=150)
    owners: Optional[Meta39] = None
    recipients: Meta38
    report_format: Optional[constr(max_length=50)] = None
    sql: Optional[str] = None
    timezone: Optional[constr(max_length=100)] = None
    type: constr(max_length=50)
    validator_config_json: Optional[str] = None
    validator_type: Optional[constr(max_length=100)] = None
    working_timeout: Optional[int] = None


class ReportScheduleRestApiGetList(BaseModel):
    active: Optional[bool] = None
    changed_by: Optional[Meta34] = None
    changed_on: Optional[datetime] = None
    changed_on_delta_humanized: Optional[Any] = None
    created_by: Optional[Meta33] = None
    created_on: Optional[datetime] = None
    creation_method: Optional[constr(max_length=255)] = None
    crontab: constr(max_length=1000)
    crontab_humanized: Optional[Any] = None
    description: Optional[str] = None
    id: Optional[int] = None
    last_eval_dttm: Optional[datetime] = None
    last_state: Optional[constr(max_length=50)] = None
    name: constr(max_length=150)
    owners: Optional[Meta36] = None
    recipients: Meta35
    timezone: Optional[constr(max_length=100)] = None
    type: constr(max_length=50)


class ReportFormat(Enum):
    PNG = 'PNG'
    CSV = 'CSV'
    TEXT = 'TEXT'


class Type2(Enum):
    Alert = 'Alert'
    Report = 'Report'


class ValidatorType(Enum):
    not_null = 'not null'
    operator = 'operator'


class Roles(BaseModel):
    id: Optional[int] = None
    name: Optional[str] = None


class SavedQueryRestApiGet(BaseModel):
    created_by: Optional[Meta31] = None
    database: Optional[Meta32] = None
    description: Optional[str] = None
    id: Optional[int] = None
    label: Optional[constr(max_length=256)] = None
    schema_: Optional[constr(max_length=128)] = Field(None, alias='schema')
    sql: Optional[str] = None
    sql_tables: Optional[Any] = None


class SavedQueryRestApiGetList(BaseModel):
    changed_on_delta_humanized: Optional[Any] = None
    created_by: Optional[Meta29] = None
    created_on: Optional[datetime] = None
    database: Optional[Meta30] = None
    db_id: Optional[int] = None
    description: Optional[str] = None
    extra: Optional[Any] = None
    id: Optional[int] = None
    label: Optional[constr(max_length=256)] = None
    last_run_delta_humanized: Optional[Any] = None
    rows: Optional[int] = None
    schema_: Optional[constr(max_length=128)] = Field(None, alias='schema')
    sql: Optional[str] = None
    sql_tables: Optional[Any] = None


class SavedQueryRestApiPost(BaseModel):
    db_id: Optional[int] = None
    description: Optional[str] = None
    label: Optional[constr(max_length=256)] = None
    schema_: Optional[constr(max_length=128)] = Field(None, alias='schema')
    sql: Optional[str] = None


class SavedQueryRestApiPut(BaseModel):
    db_id: Optional[int] = None
    description: Optional[str] = None
    label: Optional[constr(max_length=256)] = None
    schema_: Optional[constr(max_length=128)] = Field(None, alias='schema')
    sql: Optional[str] = None


class SchemasResponseSchema(BaseModel):
    result: Optional[List[str]] = None


class SelectStarResponseSchema(BaseModel):
    result: Optional[str] = Field(None, description='SQL select star')


class TableMetadataColumnsResponse(BaseModel):
    duplicates_constraint: Optional[str] = None
    keys: Optional[List[str]] = Field(None, description='')
    longType: Optional[str] = Field(
        None, description='The actual backend long type for the column'
    )
    name: Optional[str] = Field(None, description='The column name')
    type: Optional[str] = Field(None, description='The column type')


class TableMetadataOptionsResponse(BaseModel):
    deferrable: Optional[bool] = None
    initially: Optional[bool] = None
    match: Optional[bool] = None
    ondelete: Optional[bool] = None
    onupdate: Optional[bool] = None


class TableMetadataPrimaryKeyResponse(BaseModel):
    column_names: Optional[List[str]] = None
    name: Optional[str] = Field(None, description='The primary key index name')
    type: Optional[str] = None


class User(BaseModel):
    first_name: Optional[str] = None
    id: Optional[int] = None
    last_name: Optional[str] = None
    username: Optional[str] = None


class Op1(Enum):
    field_ = '<'
    field__ = '<='
    field__1 = '>'
    field___1 = '>='
    field___2 = '=='
    field___3 = '!='


class ValidatorConfigJSON(BaseModel):
    op: Optional[Op1] = Field(
        None,
        description='The operation to compare with a threshold to apply to the SQL output\n',
    )
    threshold: Optional[int] = None


class DatabaseSchemasQuerySchema(BaseModel):
    force: Optional[bool] = None


class GetDeleteIdsSchema(RootModel[List[int]]):
    root: List[int]


class GetExportIdsSchema(RootModel[List[int]]):
    root: List[int]


class GetFavStarIdsSchema1(RootModel[List[int]]):
    root: List[int]


class AddColumns(BaseModel):
    page: Optional[int] = None
    page_size: Optional[int] = None


class EditColumns(BaseModel):
    page: Optional[int] = None
    page_size: Optional[int] = None


class Key(Enum):
    add_columns = 'add_columns'
    edit_columns = 'edit_columns'
    filters = 'filters'
    permissions = 'permissions'
    add_title = 'add_title'
    edit_title = 'edit_title'
    none = 'none'


class GetInfoSchema(BaseModel):
    add_columns: Optional[Dict[str, AddColumns]] = None
    edit_columns: Optional[Dict[str, EditColumns]] = None
    keys: Optional[List[Key]] = None


class Key1(Enum):
    show_columns = 'show_columns'
    description_columns = 'description_columns'
    label_columns = 'label_columns'
    show_title = 'show_title'
    none = 'none'


class GetItemSchema(BaseModel):
    columns: Optional[List[str]] = None
    keys: Optional[List[Key1]] = None


class Filter(BaseModel):
    col: str
    opr: str
    value: Union[float, str, bool, List]


class Key2(Enum):
    list_columns = 'list_columns'
    order_columns = 'order_columns'
    label_columns = 'label_columns'
    description_columns = 'description_columns'
    list_title = 'list_title'
    none = 'none'


class OrderDirection(Enum):
    asc = 'asc'
    desc = 'desc'


class GetListSchema(BaseModel):
    columns: Optional[List[str]] = None
    filters: Optional[List[Filter]] = None
    keys: Optional[List[Key2]] = None
    order_column: Optional[str] = None
    order_direction: Optional[OrderDirection] = None
    page: Optional[int] = None
    page_size: Optional[int] = None


class GetRelatedSchema(BaseModel):
    filter: Optional[str] = None
    include_ids: Optional[List[int]] = None
    page: Optional[int] = None
    page_size: Optional[int] = None


class ScreenshotQuerySchema(BaseModel):
    force: Optional[bool] = None
    thumb_size: Optional[List[int]] = None
    window_size: Optional[List[int]] = None


class ThumbnailQuerySchema(BaseModel):
    force: Optional[bool] = None


class AnnotationLayerDeleteResponse(BaseModel):
    message: Optional[str] = None


class Q(BaseModel):
    columns: Optional[List[str]] = None
    filters: Optional[List[Filter]] = None
    keys: Optional[List[Key2]] = None
    order_column: Optional[str] = None
    order_direction: Optional[OrderDirection] = None
    page: Optional[int] = None
    page_size: Optional[int] = None


class DescriptionColumns(BaseModel):
    column_name: Optional[str] = Field(
        None,
        description='The description for the column name. Will be translated by babel',
        examples=['A Nice description for the column'],
    )


class LabelColumns(BaseModel):
    column_name: Optional[str] = Field(
        None,
        description='The label for the column name. Will be translated by babel',
        examples=['A Nice label for the column'],
    )


class AnnotationLayerGetResponse1(BaseModel):
    message: Optional[str] = None


class AnnotationLayerPostResponse(BaseModel):
    id: Optional[float] = None
    result: Optional[AnnotationLayerRestApiPost] = None


class AnnotationLayerPostResponse1(BaseModel):
    message: Optional[str] = None


class Key4(Enum):
    add_columns = 'add_columns'
    edit_columns = 'edit_columns'
    filters = 'filters'
    permissions = 'permissions'
    add_title = 'add_title'
    edit_title = 'edit_title'
    none = 'none'


class Q1(BaseModel):
    add_columns: Optional[Dict[str, AddColumns]] = None
    edit_columns: Optional[Dict[str, EditColumns]] = None
    keys: Optional[List[Key4]] = None


class ColumnNameItem(BaseModel):
    name: Optional[str] = Field(
        None, description='The filter name. Will be translated by babel'
    )
    operator: Optional[str] = Field(
        None, description='The filter operation key to use on list filters'
    )


class Filters(BaseModel):
    column_name: Optional[List[ColumnNameItem]] = None


class AnnotationLayerInfoGetResponse(BaseModel):
    add_columns: Optional[Dict[str, Any]] = None
    edit_columns: Optional[Dict[str, Any]] = None
    filters: Optional[Filters] = None
    permissions: Optional[List[str]] = Field(
        None, description='The user permissions for this API resource'
    )


class AnnotationLayerInfoGetResponse1(BaseModel):
    message: Optional[str] = None


class Q2(BaseModel):
    filter: Optional[str] = None
    include_ids: Optional[List[int]] = None
    page: Optional[int] = None
    page_size: Optional[int] = None


class AnnotationLayerRelatedColumnNameGetResponse(BaseModel):
    message: Optional[str] = None


class AnnotationLayerPkDeleteResponse(BaseModel):
    message: Optional[str] = None


class Key5(Enum):
    show_columns = 'show_columns'
    description_columns = 'description_columns'
    label_columns = 'label_columns'
    show_title = 'show_title'
    none = 'none'


class Q3(BaseModel):
    columns: Optional[List[str]] = None
    keys: Optional[List[Key5]] = None


class AnnotationLayerPkGetResponse(BaseModel):
    description_columns: Optional[DescriptionColumns] = None
    id: Optional[str] = Field(None, description='The item id')
    label_columns: Optional[LabelColumns] = None
    result: Optional[AnnotationLayerRestApiGet] = None
    show_columns: Optional[List[str]] = Field(None, description='A list of columns')
    show_title: Optional[str] = Field(
        None,
        description='A title to render. Will be translated by babel',
        examples=['Show Item Details'],
    )


class AnnotationLayerPkGetResponse1(BaseModel):
    message: Optional[str] = None


class AnnotationLayerPkPutResponse(BaseModel):
    id: Optional[float] = None
    result: Optional[AnnotationLayerRestApiPut] = None


class AnnotationLayerPkPutResponse1(BaseModel):
    message: Optional[str] = None


class AnnotationLayerPkAnnotationDeleteResponse(BaseModel):
    message: Optional[str] = None


class Key6(Enum):
    list_columns = 'list_columns'
    order_columns = 'order_columns'
    label_columns = 'label_columns'
    description_columns = 'description_columns'
    list_title = 'list_title'
    none = 'none'


class Q4(BaseModel):
    columns: Optional[List[str]] = None
    filters: Optional[List[Filter]] = None
    keys: Optional[List[Key6]] = None
    order_column: Optional[str] = None
    order_direction: Optional[OrderDirection] = None
    page: Optional[int] = None
    page_size: Optional[int] = None


class AnnotationLayerPkAnnotationGetResponse1(BaseModel):
    message: Optional[str] = None


class AnnotationLayerPkAnnotationPostResponse(BaseModel):
    id: Optional[float] = None
    result: Optional[AnnotationRestApiPost] = None


class AnnotationLayerPkAnnotationPostResponse1(BaseModel):
    message: Optional[str] = None


class AnnotationLayerPkAnnotationAnnotationIdDeleteResponse(BaseModel):
    message: Optional[str] = None


class Key7(Enum):
    show_columns = 'show_columns'
    description_columns = 'description_columns'
    label_columns = 'label_columns'
    show_title = 'show_title'
    none = 'none'


class Q5(BaseModel):
    columns: Optional[List[str]] = None
    keys: Optional[List[Key7]] = None


class AnnotationLayerPkAnnotationAnnotationIdGetResponse1(BaseModel):
    message: Optional[str] = None


class AnnotationLayerPkAnnotationAnnotationIdPutResponse(BaseModel):
    id: Optional[float] = None
    result: Optional[AnnotationRestApiPut] = None


class AnnotationLayerPkAnnotationAnnotationIdPutResponse1(BaseModel):
    message: Optional[str] = None


class ResultItem(BaseModel):
    channel_id: Optional[str] = None
    errors: Optional[List[Dict[str, Any]]] = None
    id: Optional[str] = None
    job_id: Optional[str] = None
    result_url: Optional[str] = None
    status: Optional[str] = None
    user_id: Optional[int] = None


class AsyncEventGetResponse(BaseModel):
    result: Optional[List[ResultItem]] = None


class AsyncEventGetResponse1(BaseModel):
    message: Optional[str] = None


class CachekeyInvalidatePostResponse(BaseModel):
    message: Optional[str] = None


class ChartDeleteResponse(BaseModel):
    message: Optional[str] = None


class Key8(Enum):
    list_columns = 'list_columns'
    order_columns = 'order_columns'
    label_columns = 'label_columns'
    description_columns = 'description_columns'
    list_title = 'list_title'
    none = 'none'


class Q6(BaseModel):
    columns: Optional[List[str]] = None
    filters: Optional[List[Filter]] = None
    keys: Optional[List[Key8]] = None
    order_column: Optional[str] = None
    order_direction: Optional[OrderDirection] = None
    page: Optional[int] = None
    page_size: Optional[int] = None


class ChartGetResponse1(BaseModel):
    message: Optional[str] = None


class ChartPostResponse(BaseModel):
    id: Optional[float] = None
    result: Optional[ChartRestApiPost] = None


class ChartPostResponse1(BaseModel):
    message: Optional[str] = None


class Key9(Enum):
    add_columns = 'add_columns'
    edit_columns = 'edit_columns'
    filters = 'filters'
    permissions = 'permissions'
    add_title = 'add_title'
    edit_title = 'edit_title'
    none = 'none'


class Q7(BaseModel):
    add_columns: Optional[Dict[str, AddColumns]] = None
    edit_columns: Optional[Dict[str, EditColumns]] = None
    keys: Optional[List[Key9]] = None


class Filters1(BaseModel):
    column_name: Optional[List[ColumnNameItem]] = None


class ChartInfoGetResponse(BaseModel):
    add_columns: Optional[Dict[str, Any]] = None
    edit_columns: Optional[Dict[str, Any]] = None
    filters: Optional[Filters1] = None
    permissions: Optional[List[str]] = Field(
        None, description='The user permissions for this API resource'
    )


class ChartInfoGetResponse1(BaseModel):
    message: Optional[str] = None


class ChartDataPostResponse(BaseModel):
    message: Optional[str] = None


class ChartDataCacheKeyGetResponse(BaseModel):
    message: Optional[str] = None


class ChartExportGetResponse(BaseModel):
    message: Optional[str] = None


class ChartFavoriteStatusGetResponse(BaseModel):
    message: Optional[str] = None


class ChartImportPostRequest(BaseModel):
    formData: Optional[bytes] = Field(None, description='upload file (ZIP)')
    overwrite: Optional[bool] = Field(None, description='overwrite existing databases?')
    passwords: Optional[str] = Field(
        None, description='JSON map of passwords for each file'
    )


class ChartImportPostResponse(BaseModel):
    message: Optional[str] = None


class Q8(BaseModel):
    filter: Optional[str] = None
    include_ids: Optional[List[int]] = None
    page: Optional[int] = None
    page_size: Optional[int] = None


class ChartRelatedColumnNameGetResponse(BaseModel):
    message: Optional[str] = None


class ChartPkDeleteResponse(BaseModel):
    message: Optional[str] = None


class Key10(Enum):
    show_columns = 'show_columns'
    description_columns = 'description_columns'
    label_columns = 'label_columns'
    show_title = 'show_title'
    none = 'none'


class Q9(BaseModel):
    columns: Optional[List[str]] = None
    keys: Optional[List[Key10]] = None


class ChartPkGetResponse1(BaseModel):
    message: Optional[str] = None


class ChartPkPutResponse(BaseModel):
    id: Optional[float] = None
    result: Optional[ChartRestApiPut] = None


class ChartPkPutResponse1(BaseModel):
    message: Optional[str] = None


class Q10(BaseModel):
    force: Optional[bool] = None
    thumb_size: Optional[List[int]] = None
    window_size: Optional[List[int]] = None


class ChartPkCacheScreenshotGetResponse(BaseModel):
    message: Optional[str] = None


class ChartPkDataGetResponse(BaseModel):
    message: Optional[str] = None


class ChartPkScreenshotDigestGetResponse(BaseModel):
    message: Optional[str] = None


class ChartPkThumbnailDigestGetResponse(BaseModel):
    message: Optional[str] = None


class CssTemplateDeleteResponse(BaseModel):
    message: Optional[str] = None


class Key11(Enum):
    list_columns = 'list_columns'
    order_columns = 'order_columns'
    label_columns = 'label_columns'
    description_columns = 'description_columns'
    list_title = 'list_title'
    none = 'none'


class Q11(BaseModel):
    columns: Optional[List[str]] = None
    filters: Optional[List[Filter]] = None
    keys: Optional[List[Key11]] = None
    order_column: Optional[str] = None
    order_direction: Optional[OrderDirection] = None
    page: Optional[int] = None
    page_size: Optional[int] = None


class CssTemplateGetResponse1(BaseModel):
    message: Optional[str] = None


class CssTemplatePostResponse(BaseModel):
    id: Optional[str] = None
    result: Optional[CssTemplateRestApiPost] = None


class CssTemplatePostResponse1(BaseModel):
    message: Optional[str] = None


class Key12(Enum):
    add_columns = 'add_columns'
    edit_columns = 'edit_columns'
    filters = 'filters'
    permissions = 'permissions'
    add_title = 'add_title'
    edit_title = 'edit_title'
    none = 'none'


class Q12(BaseModel):
    add_columns: Optional[Dict[str, AddColumns]] = None
    edit_columns: Optional[Dict[str, EditColumns]] = None
    keys: Optional[List[Key12]] = None


class Filters2(BaseModel):
    column_name: Optional[List[ColumnNameItem]] = None


class CssTemplateInfoGetResponse(BaseModel):
    add_columns: Optional[Dict[str, Any]] = None
    edit_columns: Optional[Dict[str, Any]] = None
    filters: Optional[Filters2] = None
    permissions: Optional[List[str]] = Field(
        None, description='The user permissions for this API resource'
    )


class CssTemplateInfoGetResponse1(BaseModel):
    message: Optional[str] = None


class Q13(BaseModel):
    filter: Optional[str] = None
    include_ids: Optional[List[int]] = None
    page: Optional[int] = None
    page_size: Optional[int] = None


class CssTemplateRelatedColumnNameGetResponse(BaseModel):
    message: Optional[str] = None


class CssTemplatePkDeleteResponse(BaseModel):
    message: Optional[str] = None


class Key13(Enum):
    show_columns = 'show_columns'
    description_columns = 'description_columns'
    label_columns = 'label_columns'
    show_title = 'show_title'
    none = 'none'


class Q14(BaseModel):
    columns: Optional[List[str]] = None
    keys: Optional[List[Key13]] = None


class CssTemplatePkGetResponse1(BaseModel):
    message: Optional[str] = None


class CssTemplatePkPutResponse(BaseModel):
    result: Optional[CssTemplateRestApiPut] = None


class CssTemplatePkPutResponse1(BaseModel):
    message: Optional[str] = None


class DashboardDeleteResponse(BaseModel):
    message: Optional[str] = None


class Key14(Enum):
    list_columns = 'list_columns'
    order_columns = 'order_columns'
    label_columns = 'label_columns'
    description_columns = 'description_columns'
    list_title = 'list_title'
    none = 'none'


class Q15(BaseModel):
    columns: Optional[List[str]] = None
    filters: Optional[List[Filter]] = None
    keys: Optional[List[Key14]] = None
    order_column: Optional[str] = None
    order_direction: Optional[OrderDirection] = None
    page: Optional[int] = None
    page_size: Optional[int] = None


class DashboardGetResponse1(BaseModel):
    message: Optional[str] = None


class DashboardPostResponse(BaseModel):
    id: Optional[float] = None
    result: Optional[DashboardRestApiPost] = None


class DashboardPostResponse1(BaseModel):
    message: Optional[str] = None


class Key15(Enum):
    add_columns = 'add_columns'
    edit_columns = 'edit_columns'
    filters = 'filters'
    permissions = 'permissions'
    add_title = 'add_title'
    edit_title = 'edit_title'
    none = 'none'


class Q16(BaseModel):
    add_columns: Optional[Dict[str, AddColumns]] = None
    edit_columns: Optional[Dict[str, EditColumns]] = None
    keys: Optional[List[Key15]] = None


class Filters3(BaseModel):
    column_name: Optional[List[ColumnNameItem]] = None


class DashboardInfoGetResponse(BaseModel):
    add_columns: Optional[Dict[str, Any]] = None
    edit_columns: Optional[Dict[str, Any]] = None
    filters: Optional[Filters3] = None
    permissions: Optional[List[str]] = Field(
        None, description='The user permissions for this API resource'
    )


class DashboardInfoGetResponse1(BaseModel):
    message: Optional[str] = None


class DashboardExportGetResponse(BaseModel):
    message: Optional[str] = None


class DashboardFavoriteStatusGetResponse(BaseModel):
    message: Optional[str] = None


class DashboardImportPostRequest(BaseModel):
    formData: Optional[bytes] = Field(None, description='upload file (ZIP or JSON)')
    overwrite: Optional[bool] = Field(None, description='overwrite existing databases?')
    passwords: Optional[str] = Field(
        None, description='JSON map of passwords for each file'
    )


class DashboardImportPostResponse(BaseModel):
    message: Optional[str] = None


class Q17(BaseModel):
    filter: Optional[str] = None
    include_ids: Optional[List[int]] = None
    page: Optional[int] = None
    page_size: Optional[int] = None


class DashboardRelatedColumnNameGetResponse(BaseModel):
    message: Optional[str] = None


class DashboardIdOrSlugGetResponse1(BaseModel):
    message: Optional[str] = None


class DashboardIdOrSlugChartsGetResponse(BaseModel):
    result: Optional[List[ChartEntityResponseSchema]] = None


class DashboardIdOrSlugChartsGetResponse1(BaseModel):
    message: Optional[str] = None


class DashboardIdOrSlugDatasetsGetResponse1(BaseModel):
    message: Optional[str] = None


class DashboardPkDeleteResponse(BaseModel):
    message: Optional[str] = None


class DashboardPkPutResponse(BaseModel):
    id: Optional[float] = None
    result: Optional[DashboardRestApiPut] = None


class DashboardPkPutResponse1(BaseModel):
    message: Optional[str] = None


class Q18(BaseModel):
    force: Optional[bool] = None


class DashboardPkThumbnailDigestGetResponse(BaseModel):
    message: Optional[str] = None


class Key16(Enum):
    list_columns = 'list_columns'
    order_columns = 'order_columns'
    label_columns = 'label_columns'
    description_columns = 'description_columns'
    list_title = 'list_title'
    none = 'none'


class Q19(BaseModel):
    columns: Optional[List[str]] = None
    filters: Optional[List[Filter]] = None
    keys: Optional[List[Key16]] = None
    order_column: Optional[str] = None
    order_direction: Optional[OrderDirection] = None
    page: Optional[int] = None
    page_size: Optional[int] = None


class DatabaseGetResponse1(BaseModel):
    message: Optional[str] = None


class DatabasePostResponse(BaseModel):
    id: Optional[float] = None
    result: Optional[DatabaseRestApiPost] = None


class DatabasePostResponse1(BaseModel):
    message: Optional[str] = None


class Key17(Enum):
    add_columns = 'add_columns'
    edit_columns = 'edit_columns'
    filters = 'filters'
    permissions = 'permissions'
    add_title = 'add_title'
    edit_title = 'edit_title'
    none = 'none'


class Q20(BaseModel):
    add_columns: Optional[Dict[str, AddColumns]] = None
    edit_columns: Optional[Dict[str, EditColumns]] = None
    keys: Optional[List[Key17]] = None


class Filters4(BaseModel):
    column_name: Optional[List[ColumnNameItem]] = None


class DatabaseInfoGetResponse(BaseModel):
    add_columns: Optional[Dict[str, Any]] = None
    edit_columns: Optional[Dict[str, Any]] = None
    filters: Optional[Filters4] = None
    permissions: Optional[List[str]] = Field(
        None, description='The user permissions for this API resource'
    )


class DatabaseInfoGetResponse1(BaseModel):
    message: Optional[str] = None


class DatabaseAvailableGetResponseItem(BaseModel):
    available_drivers: Optional[List[str]] = Field(
        None, description='Installed drivers for the engine'
    )
    default_driver: Optional[str] = Field(
        None, description='Default driver for the engine'
    )
    engine: Optional[str] = Field(None, description='Name of the SQLAlchemy engine')
    name: Optional[str] = Field(None, description='Name of the database')
    parameters: Optional[Dict[str, Any]] = Field(
        None, description='JSON schema defining the needed parameters'
    )
    preferred: Optional[bool] = Field(None, description='Is the database preferred?')
    sqlalchemy_uri_placeholder: Optional[str] = Field(
        None, description='Example placeholder for the SQLAlchemy URI'
    )


class DatabaseAvailableGetResponse(RootModel[List[DatabaseAvailableGetResponseItem]]):
    root: List[DatabaseAvailableGetResponseItem]


class DatabaseAvailableGetResponse1(BaseModel):
    message: Optional[str] = None


class DatabaseExportGetResponse(BaseModel):
    message: Optional[str] = None


class DatabaseImportPostRequest(BaseModel):
    formData: Optional[bytes] = Field(None, description='upload file (ZIP)')
    overwrite: Optional[bool] = Field(None, description='overwrite existing databases?')
    passwords: Optional[str] = Field(
        None, description='JSON map of passwords for each file'
    )


class DatabaseImportPostResponse(BaseModel):
    message: Optional[str] = None


class DatabaseTestConnectionPostResponse(BaseModel):
    message: Optional[str] = None


class DatabaseValidateParametersPostResponse(BaseModel):
    message: Optional[str] = None


class DatabasePkDeleteResponse(BaseModel):
    message: Optional[str] = None


class Key18(Enum):
    show_columns = 'show_columns'
    description_columns = 'description_columns'
    label_columns = 'label_columns'
    show_title = 'show_title'
    none = 'none'


class Q21(BaseModel):
    columns: Optional[List[str]] = None
    keys: Optional[List[Key18]] = None


class DatabasePkGetResponse(BaseModel):
    description_columns: Optional[DescriptionColumns] = None
    id: Optional[str] = Field(None, description='The item id')
    label_columns: Optional[LabelColumns] = None
    result: Optional[DatabaseRestApiGet] = None
    show_columns: Optional[List[str]] = Field(None, description='A list of columns')
    show_title: Optional[str] = Field(
        None,
        description='A title to render. Will be translated by babel',
        examples=['Show Item Details'],
    )


class DatabasePkGetResponse1(BaseModel):
    message: Optional[str] = None


class DatabasePkPutResponse(BaseModel):
    id: Optional[float] = None
    result: Optional[DatabaseRestApiPut] = None


class DatabasePkPutResponse1(BaseModel):
    message: Optional[str] = None


class DatabasePkFunctionNamesGetResponse(BaseModel):
    message: Optional[str] = None


class DatabasePkRelatedObjectsGetResponse(BaseModel):
    message: Optional[str] = None


class Q22(BaseModel):
    force: Optional[bool] = None


class DatabasePkSchemasGetResponse(BaseModel):
    message: Optional[str] = None


class DatabasePkSelectStarTableNameGetResponse(BaseModel):
    message: Optional[str] = None


class DatabasePkSelectStarTableNameSchemaNameGetResponse(BaseModel):
    message: Optional[str] = None


class DatabasePkTableTableNameSchemaNameGetResponse(BaseModel):
    message: Optional[str] = None


class DatasetDeleteResponse(BaseModel):
    message: Optional[str] = None


class Key19(Enum):
    list_columns = 'list_columns'
    order_columns = 'order_columns'
    label_columns = 'label_columns'
    description_columns = 'description_columns'
    list_title = 'list_title'
    none = 'none'


class Q23(BaseModel):
    columns: Optional[List[str]] = None
    filters: Optional[List[Filter]] = None
    keys: Optional[List[Key19]] = None
    order_column: Optional[str] = None
    order_direction: Optional[OrderDirection] = None
    page: Optional[int] = None
    page_size: Optional[int] = None


class DatasetGetResponse1(BaseModel):
    message: Optional[str] = None


class DatasetPostResponse(BaseModel):
    id: Optional[float] = None
    result: Optional[DatasetRestApiPost] = None


class DatasetPostResponse1(BaseModel):
    message: Optional[str] = None


class Key20(Enum):
    add_columns = 'add_columns'
    edit_columns = 'edit_columns'
    filters = 'filters'
    permissions = 'permissions'
    add_title = 'add_title'
    edit_title = 'edit_title'
    none = 'none'


class Q24(BaseModel):
    add_columns: Optional[Dict[str, AddColumns]] = None
    edit_columns: Optional[Dict[str, EditColumns]] = None
    keys: Optional[List[Key20]] = None


class Filters5(BaseModel):
    column_name: Optional[List[ColumnNameItem]] = None


class DatasetInfoGetResponse(BaseModel):
    add_columns: Optional[Dict[str, Any]] = None
    edit_columns: Optional[Dict[str, Any]] = None
    filters: Optional[Filters5] = None
    permissions: Optional[List[str]] = Field(
        None, description='The user permissions for this API resource'
    )


class DatasetInfoGetResponse1(BaseModel):
    message: Optional[str] = None


class Q25(BaseModel):
    filter: Optional[str] = None
    include_ids: Optional[List[int]] = None
    page: Optional[int] = None
    page_size: Optional[int] = None


class DatasetDistinctColumnNameGetResponse(BaseModel):
    message: Optional[str] = None


class DatasetExportGetResponse(BaseModel):
    message: Optional[str] = None


class DatasetImportPostRequest(BaseModel):
    formData: Optional[bytes] = Field(None, description='upload file (ZIP or YAML)')
    overwrite: Optional[bool] = Field(None, description='overwrite existing datasets?')
    passwords: Optional[str] = Field(
        None, description='JSON map of passwords for each file'
    )


class DatasetImportPostResponse(BaseModel):
    message: Optional[str] = None


class DatasetRelatedColumnNameGetResponse(BaseModel):
    message: Optional[str] = None


class DatasetPkDeleteResponse(BaseModel):
    message: Optional[str] = None


class Key21(Enum):
    show_columns = 'show_columns'
    description_columns = 'description_columns'
    label_columns = 'label_columns'
    show_title = 'show_title'
    none = 'none'


class Q27(BaseModel):
    columns: Optional[List[str]] = None
    keys: Optional[List[Key21]] = None


class DatasetPkGetResponse1(BaseModel):
    message: Optional[str] = None


class DatasetPkPutResponse(BaseModel):
    id: Optional[float] = None
    result: Optional[DatasetRestApiPut] = None


class DatasetPkPutResponse1(BaseModel):
    message: Optional[str] = None


class DatasetPkColumnColumnIdDeleteResponse(BaseModel):
    message: Optional[str] = None


class DatasetPkMetricMetricIdDeleteResponse(BaseModel):
    message: Optional[str] = None


class DatasetPkRefreshPutResponse(BaseModel):
    message: Optional[str] = None


class DatasetPkRelatedObjectsGetResponse(BaseModel):
    message: Optional[str] = None


class Key22(Enum):
    list_columns = 'list_columns'
    order_columns = 'order_columns'
    label_columns = 'label_columns'
    description_columns = 'description_columns'
    list_title = 'list_title'
    none = 'none'


class Q28(BaseModel):
    columns: Optional[List[str]] = None
    filters: Optional[List[Filter]] = None
    keys: Optional[List[Key22]] = None
    order_column: Optional[str] = None
    order_direction: Optional[OrderDirection] = None
    page: Optional[int] = None
    page_size: Optional[int] = None


class LogGetResponse1(BaseModel):
    message: Optional[str] = None


class LogPostResponse(BaseModel):
    id: Optional[str] = None
    result: Optional[LogRestApiPost] = None


class LogPostResponse1(BaseModel):
    message: Optional[str] = None


class Key23(Enum):
    show_columns = 'show_columns'
    description_columns = 'description_columns'
    label_columns = 'label_columns'
    show_title = 'show_title'
    none = 'none'


class Q29(BaseModel):
    columns: Optional[List[str]] = None
    keys: Optional[List[Key23]] = None


class LogPkGetResponse1(BaseModel):
    message: Optional[str] = None


class ResultItem1(BaseModel):
    childs: Optional[List[Dict[str, Any]]] = None
    icon: Optional[str] = Field(
        None, description='Icon name to show for this menu item'
    )
    label: Optional[str] = Field(None, description='Pretty name for the menu item')
    name: Optional[str] = Field(
        None, description='The internal menu item name, maps to permission_name'
    )
    url: Optional[str] = Field(None, description='The URL for the menu item')


class MenuGetResponse(BaseModel):
    result: Optional[List[ResultItem1]] = Field(
        None, description='Menu items in a forest like data structure'
    )


class MenuGetResponse1(BaseModel):
    message: Optional[str] = None


class OpenapiVersionOpenapiGetResponse(BaseModel):
    pass


class OpenapiVersionOpenapiGetResponse1(BaseModel):
    message: Optional[str] = None


class Key24(Enum):
    list_columns = 'list_columns'
    order_columns = 'order_columns'
    label_columns = 'label_columns'
    description_columns = 'description_columns'
    list_title = 'list_title'
    none = 'none'


class Q30(BaseModel):
    columns: Optional[List[str]] = None
    filters: Optional[List[Filter]] = None
    keys: Optional[List[Key24]] = None
    order_column: Optional[str] = None
    order_direction: Optional[OrderDirection] = None
    page: Optional[int] = None
    page_size: Optional[int] = None


class QueryGetResponse(BaseModel):
    count: Optional[float] = Field(
        None, description='The total record count on the backend'
    )
    description_columns: Optional[DescriptionColumns] = None
    ids: Optional[List[str]] = Field(
        None, description="A list of item ids, useful when you don't know the column id"
    )
    label_columns: Optional[LabelColumns] = None
    list_columns: Optional[List[str]] = Field(None, description='A list of columns')
    list_title: Optional[str] = Field(
        None,
        description='A title to render. Will be translated by babel',
        examples=['List Items'],
    )
    order_columns: Optional[List[str]] = Field(
        None, description='A list of allowed columns to sort'
    )
    result: Optional[List[QueryRestApiGetList]] = Field(
        None, description='The result from the get list query'
    )


class QueryGetResponse1(BaseModel):
    message: Optional[str] = None


class Q31(BaseModel):
    filter: Optional[str] = None
    include_ids: Optional[List[int]] = None
    page: Optional[int] = None
    page_size: Optional[int] = None


class QueryDistinctColumnNameGetResponse(BaseModel):
    message: Optional[str] = None


class QueryRelatedColumnNameGetResponse(BaseModel):
    message: Optional[str] = None


class Key25(Enum):
    show_columns = 'show_columns'
    description_columns = 'description_columns'
    label_columns = 'label_columns'
    show_title = 'show_title'
    none = 'none'


class Q33(BaseModel):
    columns: Optional[List[str]] = None
    keys: Optional[List[Key25]] = None


class QueryPkGetResponse(BaseModel):
    description_columns: Optional[DescriptionColumns] = None
    id: Optional[str] = Field(None, description='The item id')
    label_columns: Optional[LabelColumns] = None
    result: Optional[QueryRestApiGet] = None
    show_columns: Optional[List[str]] = Field(None, description='A list of columns')
    show_title: Optional[str] = Field(
        None,
        description='A title to render. Will be translated by babel',
        examples=['Show Item Details'],
    )


class QueryPkGetResponse1(BaseModel):
    message: Optional[str] = None


class ReportDeleteResponse(BaseModel):
    message: Optional[str] = None


class Key26(Enum):
    list_columns = 'list_columns'
    order_columns = 'order_columns'
    label_columns = 'label_columns'
    description_columns = 'description_columns'
    list_title = 'list_title'
    none = 'none'


class Q34(BaseModel):
    columns: Optional[List[str]] = None
    filters: Optional[List[Filter]] = None
    keys: Optional[List[Key26]] = None
    order_column: Optional[str] = None
    order_direction: Optional[OrderDirection] = None
    page: Optional[int] = None
    page_size: Optional[int] = None


class ReportGetResponse(BaseModel):
    count: Optional[float] = Field(
        None, description='The total record count on the backend'
    )
    description_columns: Optional[DescriptionColumns] = None
    ids: Optional[List[str]] = Field(
        None, description="A list of item ids, useful when you don't know the column id"
    )
    label_columns: Optional[LabelColumns] = None
    list_columns: Optional[List[str]] = Field(None, description='A list of columns')
    list_title: Optional[str] = Field(
        None,
        description='A title to render. Will be translated by babel',
        examples=['List Items'],
    )
    order_columns: Optional[List[str]] = Field(
        None, description='A list of allowed columns to sort'
    )
    result: Optional[List[ReportScheduleRestApiGetList]] = Field(
        None, description='The result from the get list query'
    )


class ReportGetResponse1(BaseModel):
    message: Optional[str] = None


class ReportPostResponse1(BaseModel):
    message: Optional[str] = None


class Key27(Enum):
    add_columns = 'add_columns'
    edit_columns = 'edit_columns'
    filters = 'filters'
    permissions = 'permissions'
    add_title = 'add_title'
    edit_title = 'edit_title'
    none = 'none'


class Q35(BaseModel):
    add_columns: Optional[Dict[str, AddColumns]] = None
    edit_columns: Optional[Dict[str, EditColumns]] = None
    keys: Optional[List[Key27]] = None


class Filters6(BaseModel):
    column_name: Optional[List[ColumnNameItem]] = None


class ReportInfoGetResponse(BaseModel):
    add_columns: Optional[Dict[str, Any]] = None
    edit_columns: Optional[Dict[str, Any]] = None
    filters: Optional[Filters6] = None
    permissions: Optional[List[str]] = Field(
        None, description='The user permissions for this API resource'
    )


class ReportInfoGetResponse1(BaseModel):
    message: Optional[str] = None


class Q36(BaseModel):
    filter: Optional[str] = None
    include_ids: Optional[List[int]] = None
    page: Optional[int] = None
    page_size: Optional[int] = None


class ReportRelatedColumnNameGetResponse(BaseModel):
    message: Optional[str] = None


class ReportPkDeleteResponse(BaseModel):
    message: Optional[str] = None


class Key28(Enum):
    show_columns = 'show_columns'
    description_columns = 'description_columns'
    label_columns = 'label_columns'
    show_title = 'show_title'
    none = 'none'


class Q37(BaseModel):
    columns: Optional[List[str]] = None
    keys: Optional[List[Key28]] = None


class ReportPkGetResponse(BaseModel):
    description_columns: Optional[DescriptionColumns] = None
    id: Optional[str] = Field(None, description='The item id')
    label_columns: Optional[LabelColumns] = None
    result: Optional[ReportScheduleRestApiGet] = None
    show_columns: Optional[List[str]] = Field(None, description='A list of columns')
    show_title: Optional[str] = Field(
        None,
        description='A title to render. Will be translated by babel',
        examples=['Show Item Details'],
    )


class ReportPkGetResponse1(BaseModel):
    message: Optional[str] = None


class ReportPkPutResponse1(BaseModel):
    message: Optional[str] = None


class Key29(Enum):
    list_columns = 'list_columns'
    order_columns = 'order_columns'
    label_columns = 'label_columns'
    description_columns = 'description_columns'
    list_title = 'list_title'
    none = 'none'


class Q38(BaseModel):
    columns: Optional[List[str]] = None
    filters: Optional[List[Filter]] = None
    keys: Optional[List[Key29]] = None
    order_column: Optional[str] = None
    order_direction: Optional[OrderDirection] = None
    page: Optional[int] = None
    page_size: Optional[int] = None


class ReportPkLogGetResponse(BaseModel):
    count: Optional[float] = Field(
        None, description='The total record count on the backend'
    )
    ids: Optional[List[str]] = Field(None, description='A list of log ids')
    result: Optional[List[ReportExecutionLogRestApiGetList]] = Field(
        None, description='The result from the get list query'
    )


class ReportPkLogGetResponse1(BaseModel):
    message: Optional[str] = None


class Key30(Enum):
    show_columns = 'show_columns'
    description_columns = 'description_columns'
    label_columns = 'label_columns'
    show_title = 'show_title'
    none = 'none'


class Q39(BaseModel):
    columns: Optional[List[str]] = None
    keys: Optional[List[Key30]] = None


class ReportPkLogLogIdGetResponse(BaseModel):
    id: Optional[str] = Field(None, description='The log id')
    result: Optional[ReportExecutionLogRestApiGet] = None


class ReportPkLogLogIdGetResponse1(BaseModel):
    message: Optional[str] = None


class SavedQueryDeleteResponse(BaseModel):
    message: Optional[str] = None


class Key31(Enum):
    list_columns = 'list_columns'
    order_columns = 'order_columns'
    label_columns = 'label_columns'
    description_columns = 'description_columns'
    list_title = 'list_title'
    none = 'none'


class Q40(BaseModel):
    columns: Optional[List[str]] = None
    filters: Optional[List[Filter]] = None
    keys: Optional[List[Key31]] = None
    order_column: Optional[str] = None
    order_direction: Optional[OrderDirection] = None
    page: Optional[int] = None
    page_size: Optional[int] = None


class SavedQueryGetResponse(BaseModel):
    count: Optional[float] = Field(
        None, description='The total record count on the backend'
    )
    description_columns: Optional[DescriptionColumns] = None
    ids: Optional[List[str]] = Field(
        None, description="A list of item ids, useful when you don't know the column id"
    )
    label_columns: Optional[LabelColumns] = None
    list_columns: Optional[List[str]] = Field(None, description='A list of columns')
    list_title: Optional[str] = Field(
        None,
        description='A title to render. Will be translated by babel',
        examples=['List Items'],
    )
    order_columns: Optional[List[str]] = Field(
        None, description='A list of allowed columns to sort'
    )
    result: Optional[List[SavedQueryRestApiGetList]] = Field(
        None, description='The result from the get list query'
    )


class SavedQueryGetResponse1(BaseModel):
    message: Optional[str] = None


class SavedQueryPostResponse(BaseModel):
    id: Optional[str] = None
    result: Optional[SavedQueryRestApiPost] = None


class SavedQueryPostResponse1(BaseModel):
    message: Optional[str] = None


class Key32(Enum):
    add_columns = 'add_columns'
    edit_columns = 'edit_columns'
    filters = 'filters'
    permissions = 'permissions'
    add_title = 'add_title'
    edit_title = 'edit_title'
    none = 'none'


class Q41(BaseModel):
    add_columns: Optional[Dict[str, AddColumns]] = None
    edit_columns: Optional[Dict[str, EditColumns]] = None
    keys: Optional[List[Key32]] = None


class Filters7(BaseModel):
    column_name: Optional[List[ColumnNameItem]] = None


class SavedQueryInfoGetResponse(BaseModel):
    add_columns: Optional[Dict[str, Any]] = None
    edit_columns: Optional[Dict[str, Any]] = None
    filters: Optional[Filters7] = None
    permissions: Optional[List[str]] = Field(
        None, description='The user permissions for this API resource'
    )


class SavedQueryInfoGetResponse1(BaseModel):
    message: Optional[str] = None


class Q42(BaseModel):
    filter: Optional[str] = None
    include_ids: Optional[List[int]] = None
    page: Optional[int] = None
    page_size: Optional[int] = None


class SavedQueryDistinctColumnNameGetResponse(BaseModel):
    message: Optional[str] = None


class SavedQueryExportGetResponse(BaseModel):
    message: Optional[str] = None


class SavedQueryImportPostRequest(BaseModel):
    formData: Optional[bytes] = Field(None, description='upload file (ZIP)')
    overwrite: Optional[bool] = Field(
        None, description='overwrite existing saved queries?'
    )
    passwords: Optional[str] = Field(
        None, description='JSON map of passwords for each file'
    )


class SavedQueryImportPostResponse(BaseModel):
    message: Optional[str] = None


class SavedQueryRelatedColumnNameGetResponse(BaseModel):
    message: Optional[str] = None


class SavedQueryPkDeleteResponse(BaseModel):
    message: Optional[str] = None


class Key33(Enum):
    show_columns = 'show_columns'
    description_columns = 'description_columns'
    label_columns = 'label_columns'
    show_title = 'show_title'
    none = 'none'


class Q44(BaseModel):
    columns: Optional[List[str]] = None
    keys: Optional[List[Key33]] = None


class SavedQueryPkGetResponse(BaseModel):
    description_columns: Optional[DescriptionColumns] = None
    id: Optional[str] = Field(None, description='The item id')
    label_columns: Optional[LabelColumns] = None
    result: Optional[SavedQueryRestApiGet] = None
    show_columns: Optional[List[str]] = Field(None, description='A list of columns')
    show_title: Optional[str] = Field(
        None,
        description='A title to render. Will be translated by babel',
        examples=['Show Item Details'],
    )


class SavedQueryPkGetResponse1(BaseModel):
    message: Optional[str] = None


class SavedQueryPkPutResponse(BaseModel):
    result: Optional[SavedQueryRestApiPut] = None


class SavedQueryPkPutResponse1(BaseModel):
    message: Optional[str] = None


class SecurityCsrfTokenGetResponse(BaseModel):
    result: Optional[str] = None


class SecurityCsrfTokenGetResponse1(BaseModel):
    message: Optional[str] = None


class Provider(Enum):
    db = 'db'
    ldap = 'ldap'


class SecurityLoginPostRequest(BaseModel):
    password: Optional[str] = Field(
        None,
        description='The password for authentication',
        examples=['complex-password'],
    )
    provider: Optional[Provider] = Field(
        None, description='Choose an authentication provider', examples=['db']
    )
    refresh: Optional[bool] = Field(
        None, description='If true a refresh token is provided also', examples=[True]
    )
    username: Optional[str] = Field(
        None, description='The username for authentication', examples=['admin']
    )


class SecurityLoginPostResponse(BaseModel):
    access_token: Optional[str] = None
    refresh_token: Optional[str] = None


class SecurityLoginPostResponse1(BaseModel):
    message: Optional[str] = None


class SecurityRefreshPostResponse(BaseModel):
    access_token: Optional[str] = Field(
        None, description='A new refreshed access token'
    )


class SecurityRefreshPostResponse1(BaseModel):
    message: Optional[str] = None


class AnnotationLayerRestApiGetList(BaseModel):
    changed_by: Optional[Meta4] = None
    changed_on: Optional[datetime] = None
    changed_on_delta_humanized: Optional[Any] = None
    created_by: Optional[Meta3] = None
    created_on: Optional[datetime] = None
    descr: Optional[str] = None
    id: Optional[int] = None
    name: Optional[constr(max_length=250)] = None


class AnnotationRestApiGet(BaseModel):
    end_dttm: Optional[datetime] = None
    id: Optional[int] = None
    json_metadata: Optional[str] = None
    layer: Meta2
    long_descr: Optional[str] = None
    short_descr: Optional[constr(max_length=500)] = None
    start_dttm: Optional[datetime] = None


class AnnotationRestApiGetList(BaseModel):
    changed_by: Optional[Meta1] = None
    changed_on_delta_humanized: Optional[Any] = None
    created_by: Optional[Meta] = None
    end_dttm: Optional[datetime] = None
    id: Optional[int] = None
    long_descr: Optional[str] = None
    short_descr: Optional[constr(max_length=500)] = None
    start_dttm: Optional[datetime] = None


class CacheInvalidationRequestSchema(BaseModel):
    datasource_uids: Optional[List[str]] = Field(
        None,
        description='The uid of the dataset/datasource this new chart will use. A complete datasource identification needs `datasouce_uid` ',
    )
    datasources: Optional[List[Datasource]] = Field(
        None, description='A list of the data source and database names'
    )


class ChartDataAdhocMetricSchema(BaseModel):
    aggregate: Optional[Aggregate] = Field(
        None,
        description='Aggregation operator. Only required for simple expression types.',
    )
    column: Optional[ChartDataColumn] = None
    expressionType: ExpressionType = Field(
        ..., description='Simple or SQL metric', examples=['SQL']
    )
    hasCustomLabel: Optional[bool] = Field(
        None,
        description='When false, the label will be automatically generated based on the aggregate expression. When true, a custom label has to be specified.',
        examples=[True],
    )
    label: Optional[str] = Field(
        None,
        description='Label for the metric. Is automatically generated unless hasCustomLabel is true, in which case label must be defined.',
        examples=['Weighted observations'],
    )
    optionName: Optional[str] = Field(
        None,
        description='Unique identifier. Can be any string value, as long as all metrics have a unique identifier. If undefined, a random name will be generated.',
        examples=['metric_aec60732-fac0-4b17-b736-93f1a5c93e30'],
    )
    sqlExpression: Optional[str] = Field(
        None,
        description='The metric as defined by a SQL aggregate expression. Only required for SQL expression type.',
        examples=['SUM(weight * observations) / SUM(weight)'],
    )


class ChartDataExtras(BaseModel):
    druid_time_origin: Optional[str] = Field(
        None,
        description='Starting point for time grain counting on legacy Druid datasources. Used to change e.g. Monday/Sunday first-day-of-week.',
    )
    having: Optional[str] = Field(
        None,
        description='HAVING clause to be added to aggregate queries using AND operator.',
    )
    having_druid: Optional[List[ChartDataFilter]] = Field(
        None,
        description='HAVING filters to be added to legacy Druid datasource queries.',
    )
    relative_end: Optional[RelativeEnd] = Field(
        None,
        description='End time for relative time deltas. Default: `config["DEFAULT_RELATIVE_START_TIME"]`',
    )
    relative_start: Optional[RelativeStart] = Field(
        None,
        description='Start time for relative time deltas. Default: `config["DEFAULT_RELATIVE_START_TIME"]`',
    )
    time_grain_sqla: Optional[TimeGrainSqla] = Field(
        None,
        description='To what level of granularity should the temporal column be aggregated. Supports [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Durations) durations.',
        examples=['P1D'],
    )
    time_range_endpoints: Optional[List] = None
    where: Optional[str] = Field(
        None, description='WHERE clause to be added to queries using AND operator.'
    )


class ChartDataQueryObject(BaseModel):
    annotation_layers: Optional[List[AnnotationLayer]] = Field(
        None, description='Annotation layers to apply to chart'
    )
    applied_time_extras: Optional[Dict[str, Any]] = Field(
        None,
        description='A mapping of temporal extras that have been applied to the query',
        examples=[{'__time_range': '1 year ago : now'}],
    )
    apply_fetch_values_predicate: Optional[bool] = Field(
        None,
        description='Add fetch values predicate (where clause) to query if defined in datasource',
    )
    columns: Optional[List[str]] = Field(
        None, description='Columns which to select in the query.'
    )
    datasource: Optional[ChartDataDatasource] = None
    druid_time_origin: Optional[str] = Field(
        None,
        description='Starting point for time grain counting on legacy Druid datasources. Used to change e.g. Monday/Sunday first-day-of-week. This field is deprecated and should be passed to `extras` as `druid_time_origin`.',
    )
    extras: Optional[ChartDataExtras] = Field(
        None, description='Extra parameters to add to the query.'
    )
    filters: Optional[List[ChartDataFilter]] = None
    granularity: Optional[str] = Field(
        None,
        description='Name of temporal column used for time filtering. For legacy Druid datasources this defines the time grain.',
    )
    granularity_sqla: Optional[str] = Field(
        None,
        description='Name of temporal column used for time filtering for SQL datasources. This field is deprecated, use `granularity` instead.',
    )
    groupby: Optional[List[str]] = None
    having: Optional[str] = Field(
        None,
        description='HAVING clause to be added to aggregate queries using AND operator. This field is deprecated and should be passed to `extras`.',
    )
    having_filters: Optional[List[ChartDataFilter]] = Field(
        None,
        description='HAVING filters to be added to legacy Druid datasource queries. This field is deprecated and should be passed to `extras` as `having_druid`.',
    )
    is_rowcount: Optional[bool] = Field(
        None, description='Should the rowcount of the actual query be returned'
    )
    is_timeseries: Optional[bool] = Field(
        None, description='Is the `query_object` a timeseries.'
    )
    metrics: Optional[List] = Field(
        None,
        description='Aggregate expressions. Metrics can be passed as both references to datasource metrics (strings), or ad-hoc metricswhich are defined only within the query object. See `ChartDataAdhocMetricSchema` for the structure of ad-hoc metrics.',
    )
    order_desc: Optional[bool] = Field(
        None, description='Reverse order. Default: `false`'
    )
    orderby: Optional[List] = Field(
        None,
        description='Expects a list of lists where the first element is the column name which to sort by, and the second element is a boolean.',
        examples=[[['my_col_1', False], ['my_col_2', True]]],
    )
    post_processing: Optional[List[ChartDataPostProcessingOperation]] = Field(
        None,
        description='Post processing operations to be applied to the result set. Operations are applied to the result set in sequential order.',
    )
    result_type: Optional[Any] = None
    row_limit: Optional[conint(ge=0)] = Field(
        None,
        description='Maximum row count (0=disabled). Default: `config["ROW_LIMIT"]`',
    )
    row_offset: Optional[conint(ge=0)] = Field(
        None, description='Number of rows to skip. Default: `0`'
    )
    time_offsets: Optional[List[str]] = None
    time_range: Optional[str] = Field(
        None,
        description='A time rage, either expressed as a colon separated string `since : until` or human readable freeform. Valid formats for `since` and `until` are: \n- ISO 8601\n- X days/years/hours/day/year/weeks\n- X days/years/hours/day/year/weeks ago\n- X days/years/hours/day/year/weeks from now\n\nAdditionally, the following freeform can be used:\n\n- Last day\n- Last week\n- Last month\n- Last quarter\n- Last year\n- No filter\n- Last X seconds/minutes/hours/days/weeks/months/years\n- Next X seconds/minutes/hours/days/weeks/months/years\n',
        examples=['Last week'],
    )
    time_shift: Optional[str] = Field(
        None,
        description='A human-readable date/time string. Please refer to [parsdatetime](https://github.com/bear/parsedatetime) documentation for details on valid values.',
    )
    timeseries_limit: Optional[int] = Field(
        None, description='Maximum row count for timeseries queries. Default: `0`'
    )
    timeseries_limit_metric: Optional[Any] = Field(
        None, description='Metric used to limit timeseries queries by.'
    )
    url_params: Optional[Dict[str, str]] = Field(
        None,
        description='Optional query parameters passed to a dashboard or Explore view',
    )
    where: Optional[str] = Field(
        None,
        description='WHERE clause to be added to queries using AND operator.This field is deprecated and should be passed to `extras`.',
    )


class ChartRestApiGet(BaseModel):
    cache_timeout: Optional[int] = None
    dashboards: Optional[Meta9] = None
    description: Optional[str] = None
    owners: Optional[Meta10] = None
    params: Optional[str] = None
    query_context: Optional[str] = None
    slice_name: Optional[constr(max_length=250)] = None
    viz_type: Optional[constr(max_length=250)] = None


class ChartRestApiGetList(BaseModel):
    cache_timeout: Optional[int] = None
    changed_by: Optional[Meta8] = None
    changed_by_name: Optional[Any] = None
    changed_by_url: Optional[Any] = None
    changed_on_delta_humanized: Optional[Any] = None
    changed_on_utc: Optional[Any] = None
    created_by: Optional[Meta5] = None
    datasource_id: Optional[int] = None
    datasource_name_text: Optional[Any] = None
    datasource_type: Optional[constr(max_length=200)] = None
    datasource_url: Optional[Any] = None
    description: Optional[str] = None
    description_markeddown: Optional[Any] = None
    edit_url: Optional[Any] = None
    id: Optional[int] = None
    owners: Optional[Meta7] = None
    params: Optional[str] = None
    slice_name: Optional[constr(max_length=250)] = None
    table: Optional[Meta6] = None
    thumbnail_url: Optional[Any] = None
    url: Optional[Any] = None
    viz_type: Optional[constr(max_length=250)] = None


class CssTemplateRestApiGet(BaseModel):
    created_by: Optional[Meta13] = None
    css: Optional[str] = None
    id: Optional[int] = None
    template_name: Optional[constr(max_length=250)] = None


class CssTemplateRestApiGetList(BaseModel):
    changed_by: Optional[Meta12] = None
    changed_on_delta_humanized: Optional[Any] = None
    created_by: Optional[Meta11] = None
    created_on: Optional[datetime] = None
    css: Optional[str] = None
    id: Optional[int] = None
    template_name: Optional[constr(max_length=250)] = None


class DashboardDatasetSchema(BaseModel):
    cache_timeout: Optional[int] = None
    column_formats: Optional[Dict[str, Any]] = None
    column_types: Optional[List[int]] = None
    columns: Optional[List[Dict[str, Any]]] = None
    database: Optional[Database] = None
    datasource_name: Optional[str] = None
    default_endpoint: Optional[str] = None
    edit_url: Optional[str] = None
    fetch_values_predicate: Optional[str] = None
    filter_select: Optional[bool] = None
    filter_select_enabled: Optional[bool] = None
    granularity_sqla: Optional[List[List[str]]] = None
    health_check_message: Optional[str] = None
    id: Optional[int] = None
    is_sqllab_view: Optional[bool] = None
    main_dttm_col: Optional[str] = None
    metrics: Optional[List[Dict[str, Any]]] = None
    name: Optional[str] = None
    offset: Optional[int] = None
    order_by_choices: Optional[List[List[str]]] = None
    owners: Optional[List[int]] = None
    params: Optional[str] = None
    perm: Optional[str] = None
    schema_: Optional[str] = Field(None, alias='schema')
    select_star: Optional[str] = None
    sql: Optional[str] = None
    table_name: Optional[str] = None
    template_params: Optional[str] = None
    time_grain_sqla: Optional[List[List[str]]] = None
    type: Optional[str] = None
    uid: Optional[str] = None
    verbose_map: Optional[Dict[str, str]] = None


class DashboardGetResponseSchema(BaseModel):
    changed_by: Optional[User] = None
    changed_by_name: Optional[str] = None
    changed_by_url: Optional[str] = None
    changed_on: Optional[datetime] = None
    changed_on_delta_humanized: Optional[str] = None
    charts: Optional[List[str]] = None
    css: Optional[str] = Field(None, description='Override CSS for the dashboard.')
    dashboard_title: Optional[str] = Field(
        None, description='A title for the dashboard.'
    )
    id: Optional[int] = None
    json_metadata: Optional[str] = Field(
        None,
        description='This JSON object is generated dynamically when clicking the save or overwrite button in the dashboard view. It is exposed here for reference and for power users who may want to alter  specific parameters.',
    )
    owners: Optional[List[User]] = None
    position_json: Optional[str] = Field(
        None,
        description='This json object describes the positioning of the widgets in the dashboard. It is dynamically generated when adjusting the widgets size and positions by using drag & drop in the dashboard view',
    )
    published: Optional[bool] = None
    roles: Optional[List[Roles]] = None
    slug: Optional[str] = None
    table_names: Optional[str] = None
    thumbnail_url: Optional[str] = None
    url: Optional[str] = None


class DashboardRestApiGetList(BaseModel):
    changed_by: Optional[Meta15] = None
    changed_by_name: Optional[Any] = None
    changed_by_url: Optional[Any] = None
    changed_on_delta_humanized: Optional[Any] = None
    changed_on_utc: Optional[Any] = None
    created_by: Optional[Meta14] = None
    css: Optional[str] = None
    dashboard_title: Optional[constr(max_length=500)] = None
    id: Optional[int] = None
    json_metadata: Optional[str] = None
    owners: Optional[Meta17] = None
    position_json: Optional[str] = None
    published: Optional[bool] = None
    roles: Optional[Meta16] = None
    slug: Optional[constr(max_length=255)] = None
    status: Optional[Any] = None
    thumbnail_url: Optional[Any] = None
    url: Optional[Any] = None


class DatabaseRestApiGetList(BaseModel):
    allow_csv_upload: Optional[bool] = None
    allow_ctas: Optional[bool] = None
    allow_cvas: Optional[bool] = None
    allow_dml: Optional[bool] = None
    allow_multi_schema_metadata_fetch: Optional[bool] = None
    allow_run_async: Optional[bool] = None
    allows_cost_estimate: Optional[Any] = None
    allows_subquery: Optional[Any] = None
    allows_virtual_table_explore: Optional[Any] = None
    backend: Optional[Any] = None
    changed_on: Optional[datetime] = None
    changed_on_delta_humanized: Optional[Any] = None
    created_by: Optional[Meta18] = None
    database_name: constr(max_length=250)
    explore_database_id: Optional[Any] = None
    expose_in_sqllab: Optional[bool] = None
    extra: Optional[str] = None
    force_ctas_schema: Optional[constr(max_length=250)] = None
    id: Optional[int] = None


class DatasetRestApiGet(BaseModel):
    cache_timeout: Optional[int] = None
    columns: Meta22
    database: Meta23
    datasource_type: Optional[Any] = None
    default_endpoint: Optional[str] = None
    description: Optional[str] = None
    extra: Optional[str] = None
    fetch_values_predicate: Optional[constr(max_length=1000)] = None
    filter_select_enabled: Optional[bool] = None
    id: Optional[int] = None
    is_sqllab_view: Optional[bool] = None
    main_dttm_col: Optional[constr(max_length=250)] = None
    metrics: Meta25
    offset: Optional[int] = None
    owners: Optional[Meta24] = None
    schema_: Optional[constr(max_length=255)] = Field(None, alias='schema')
    sql: Optional[str] = None
    table_name: constr(max_length=250)
    template_params: Optional[str] = None
    url: Optional[Any] = None


class DatasetRestApiGetList(BaseModel):
    changed_by: Optional[Meta19] = None
    changed_by_name: Optional[Any] = None
    changed_by_url: Optional[Any] = None
    changed_on_delta_humanized: Optional[Any] = None
    changed_on_utc: Optional[Any] = None
    database: Meta21
    default_endpoint: Optional[str] = None
    explore_url: Optional[Any] = None
    extra: Optional[str] = None
    id: Optional[int] = None
    kind: Optional[Any] = None
    owners: Optional[Meta20] = None
    schema_: Optional[constr(max_length=255)] = Field(None, alias='schema')
    sql: Optional[str] = None
    table_name: constr(max_length=250)


class DistincResponseSchema(BaseModel):
    count: Optional[int] = Field(
        None, description='The total number of distinct values'
    )
    result: Optional[List[DistinctResultResponse]] = None


class LogRestApiGet(BaseModel):
    action: Optional[constr(max_length=512)] = None
    dashboard_id: Optional[int] = None
    dttm: Optional[datetime] = None
    duration_ms: Optional[int] = None
    json_: Optional[str] = Field(None, alias='json')
    referrer: Optional[constr(max_length=1024)] = None
    slice_id: Optional[int] = None
    user: Optional[Meta43] = None
    user_id: Optional[int] = None


class LogRestApiGetList(BaseModel):
    action: Optional[constr(max_length=512)] = None
    dashboard_id: Optional[int] = None
    dttm: Optional[datetime] = None
    duration_ms: Optional[int] = None
    json_: Optional[str] = Field(None, alias='json')
    referrer: Optional[constr(max_length=1024)] = None
    slice_id: Optional[int] = None
    user: Optional[Meta42] = None
    user_id: Optional[int] = None


class RelatedResponseSchema(BaseModel):
    count: Optional[int] = Field(None, description='The total number of related values')
    result: Optional[List[RelatedResultResponse]] = None


class ReportRecipient(BaseModel):
    recipient_config_json: Optional[ReportRecipientConfigJSON] = None
    type: Type1 = Field(
        ..., description='The recipient type, check spec for valid options'
    )


class ReportScheduleRestApiPost(BaseModel):
    active: Optional[bool] = None
    chart: Optional[int] = None
    context_markdown: Optional[str] = Field(None, description='Markdown description')
    creation_method: Optional[Any] = Field(
        None,
        description='Creation method is used to inform the frontend whether the report/alert was created in the dashboard, chart, or alerts and reports UI.',
    )
    crontab: constr(min_length=1, max_length=1000) = Field(
        ...,
        description='A CRON expression.[Crontab Guru](https://crontab.guru/) is a helpful resource that can help you craft a CRON expression.',
        examples=['*/5 * * * *'],
    )
    dashboard: Optional[int] = None
    database: Optional[int] = None
    description: Optional[str] = Field(
        None,
        description='Use a nice description to give context to this Alert/Report',
        examples=['Daily sales dashboard to marketing'],
    )
    grace_period: Optional[conint(ge=1)] = Field(
        None,
        description='Once an alert is triggered, how long, in seconds, before Superset nags you again. (in seconds)',
        examples=[14400],
    )
    log_retention: Optional[conint(ge=1)] = Field(
        None,
        description='How long to keep the logs around for this report (in days)',
        examples=[90],
    )
    name: constr(min_length=1, max_length=150) = Field(
        ..., description='The report schedule name.', examples=['Daily dashboard email']
    )
    owners: Optional[List[int]] = None
    recipients: Optional[List[ReportRecipient]] = None
    report_format: Optional[ReportFormat] = None
    sql: Optional[str] = Field(
        None,
        description='A SQL statement that defines whether the alert should get triggered or not. The query is expected to return either NULL or a number value.',
        examples=['SELECT value FROM time_series_table'],
    )
    timezone: Optional[str] = Field(
        None,
        description='A timezone string that represents the location of the timezone.',
    )
    type: Type2 = Field(..., description='The report schedule type')
    validator_config_json: Optional[ValidatorConfigJSON] = None
    validator_type: Optional[ValidatorType] = Field(
        None,
        description='Determines when to trigger alert based off value from alert query. Alerts will be triggered with these validator types:\n- Not Null - When the return value is Not NULL, Empty, or 0\n- Operator - When `sql_return_value comparison_operator threshold` is True e.g. `50 <= 75`<br>Supports the comparison operators <, <=, >, >=, ==, and !=',
    )
    working_timeout: Optional[conint(ge=1)] = Field(
        None,
        description="If an alert is staled at a working state, how long until it's state is reseted to error",
        examples=[3600],
    )


class ReportScheduleRestApiPut(BaseModel):
    active: Optional[bool] = None
    chart: Optional[int] = None
    context_markdown: Optional[str] = Field(None, description='Markdown description')
    creation_method: Optional[Any] = Field(
        None,
        description='Creation method is used to inform the frontend whether the report/alert was created in the dashboard, chart, or alerts and reports UI.',
    )
    crontab: Optional[constr(min_length=1, max_length=1000)] = Field(
        None,
        description='A CRON expression.[Crontab Guru](https://crontab.guru/) is a helpful resource that can help you craft a CRON expression.',
    )
    dashboard: Optional[int] = None
    database: Optional[int] = None
    description: Optional[str] = Field(
        None,
        description='Use a nice description to give context to this Alert/Report',
        examples=['Daily sales dashboard to marketing'],
    )
    grace_period: Optional[conint(ge=1)] = Field(
        None,
        description='Once an alert is triggered, how long, in seconds, before Superset nags you again. (in seconds)',
        examples=[14400],
    )
    log_retention: Optional[conint(ge=1)] = Field(
        None,
        description='How long to keep the logs around for this report (in days)',
        examples=[90],
    )
    name: Optional[constr(min_length=1, max_length=150)] = Field(
        None, description='The report schedule name.'
    )
    owners: Optional[List[int]] = None
    recipients: Optional[List[ReportRecipient]] = None
    report_format: Optional[ReportFormat] = None
    sql: Optional[str] = Field(
        None,
        description='A SQL statement that defines whether the alert should get triggered or not. The query is expected to return either NULL or a number value.',
        examples=['SELECT value FROM time_series_table'],
    )
    timezone: Optional[str] = Field(
        None,
        description='A timezone string that represents the location of the timezone.',
    )
    type: Optional[Type2] = Field(None, description='The report schedule type')
    validator_config_json: Optional[ValidatorConfigJSON] = None
    validator_type: Optional[ValidatorType] = Field(
        None,
        description='Determines when to trigger alert based off value from alert query. Alerts will be triggered with these validator types:\n- Not Null - When the return value is Not NULL, Empty, or 0\n- Operator - When `sql_return_value comparison_operator threshold` is True e.g. `50 <= 75`<br>Supports the comparison operators <, <=, >, >=, ==, and !=',
    )
    working_timeout: Optional[conint(ge=1)] = Field(
        None,
        description="If an alert is staled at a working state, how long until it's state is reseted to error",
        examples=[3600],
    )


class TableMetadataForeignKeysIndexesResponse(BaseModel):
    column_names: Optional[List[str]] = None
    name: Optional[str] = Field(
        None, description='The name of the foreign key or index'
    )
    options: Optional[TableMetadataOptionsResponse] = None
    referred_columns: Optional[List[str]] = None
    referred_schema: Optional[str] = None
    referred_table: Optional[str] = None
    type: Optional[str] = None


class TableMetadataResponseSchema(BaseModel):
    columns: Optional[List[TableMetadataColumnsResponse]] = Field(
        None, description='A list of columns and their metadata'
    )
    foreignKeys: Optional[List[TableMetadataForeignKeysIndexesResponse]] = Field(
        None, description='A list of foreign keys and their metadata'
    )
    indexes: Optional[List[TableMetadataForeignKeysIndexesResponse]] = Field(
        None, description='A list of indexes and their metadata'
    )
    name: Optional[str] = Field(None, description='The name of the table')
    primaryKey: Optional[TableMetadataPrimaryKeyResponse] = Field(
        None, description='Primary keys metadata'
    )
    selectStar: Optional[str] = Field(None, description='SQL select star')


class AnnotationLayerGetResponse(BaseModel):
    count: Optional[float] = Field(
        None, description='The total record count on the backend'
    )
    description_columns: Optional[DescriptionColumns] = None
    ids: Optional[List[str]] = Field(
        None, description="A list of item ids, useful when you don't know the column id"
    )
    label_columns: Optional[LabelColumns] = None
    list_columns: Optional[List[str]] = Field(None, description='A list of columns')
    list_title: Optional[str] = Field(
        None,
        description='A title to render. Will be translated by babel',
        examples=['List Items'],
    )
    order_columns: Optional[List[str]] = Field(
        None, description='A list of allowed columns to sort'
    )
    result: Optional[List[AnnotationLayerRestApiGetList]] = Field(
        None, description='The result from the get list query'
    )


class AnnotationLayerPkAnnotationGetResponse(BaseModel):
    count: Optional[float] = Field(
        None, description='The total record count on the backend'
    )
    ids: Optional[List[str]] = Field(None, description='A list of annotation ids')
    result: Optional[List[AnnotationRestApiGetList]] = Field(
        None, description='The result from the get list query'
    )


class AnnotationLayerPkAnnotationAnnotationIdGetResponse(BaseModel):
    id: Optional[str] = Field(None, description='The item id')
    result: Optional[AnnotationRestApiGet] = None


class ChartGetResponse(BaseModel):
    count: Optional[float] = Field(
        None, description='The total record count on the backend'
    )
    description_columns: Optional[DescriptionColumns] = None
    ids: Optional[List[str]] = Field(
        None, description="A list of item ids, useful when you don't know the column id"
    )
    label_columns: Optional[LabelColumns] = None
    list_columns: Optional[List[str]] = Field(None, description='A list of columns')
    list_title: Optional[str] = Field(
        None,
        description='A title to render. Will be translated by babel',
        examples=['List Items'],
    )
    order_columns: Optional[List[str]] = Field(
        None, description='A list of allowed columns to sort'
    )
    result: Optional[List[ChartRestApiGetList]] = Field(
        None, description='The result from the get list query'
    )


class ChartPkGetResponse(BaseModel):
    description_columns: Optional[DescriptionColumns] = None
    id: Optional[str] = Field(None, description='The item id')
    label_columns: Optional[LabelColumns] = None
    result: Optional[ChartRestApiGet] = None
    show_columns: Optional[List[str]] = Field(None, description='A list of columns')
    show_title: Optional[str] = Field(
        None,
        description='A title to render. Will be translated by babel',
        examples=['Show Item Details'],
    )


class CssTemplateGetResponse(BaseModel):
    count: Optional[float] = Field(
        None, description='The total record count on the backend'
    )
    description_columns: Optional[DescriptionColumns] = None
    ids: Optional[List[str]] = Field(
        None, description="A list of item ids, useful when you don't know the column id"
    )
    label_columns: Optional[LabelColumns] = None
    list_columns: Optional[List[str]] = Field(None, description='A list of columns')
    list_title: Optional[str] = Field(
        None,
        description='A title to render. Will be translated by babel',
        examples=['List Items'],
    )
    order_columns: Optional[List[str]] = Field(
        None, description='A list of allowed columns to sort'
    )
    result: Optional[List[CssTemplateRestApiGetList]] = Field(
        None, description='The result from the get list query'
    )


class CssTemplatePkGetResponse(BaseModel):
    description_columns: Optional[DescriptionColumns] = None
    id: Optional[str] = Field(None, description='The item id')
    label_columns: Optional[LabelColumns] = None
    result: Optional[CssTemplateRestApiGet] = None
    show_columns: Optional[List[str]] = Field(None, description='A list of columns')
    show_title: Optional[str] = Field(
        None,
        description='A title to render. Will be translated by babel',
        examples=['Show Item Details'],
    )


class DashboardGetResponse(BaseModel):
    count: Optional[float] = Field(
        None, description='The total record count on the backend'
    )
    description_columns: Optional[DescriptionColumns] = None
    ids: Optional[List[str]] = Field(
        None, description="A list of item ids, useful when you don't know the column id"
    )
    label_columns: Optional[LabelColumns] = None
    list_columns: Optional[List[str]] = Field(None, description='A list of columns')
    list_title: Optional[str] = Field(
        None,
        description='A title to render. Will be translated by babel',
        examples=['List Items'],
    )
    order_columns: Optional[List[str]] = Field(
        None, description='A list of allowed columns to sort'
    )
    result: Optional[List[DashboardRestApiGetList]] = Field(
        None, description='The result from the get list query'
    )


class DashboardIdOrSlugGetResponse(BaseModel):
    result: Optional[DashboardGetResponseSchema] = None


class DashboardIdOrSlugDatasetsGetResponse(BaseModel):
    result: Optional[List[DashboardDatasetSchema]] = None


class DatabaseGetResponse(BaseModel):
    count: Optional[float] = Field(
        None, description='The total record count on the backend'
    )
    description_columns: Optional[DescriptionColumns] = None
    ids: Optional[List[str]] = Field(
        None, description="A list of item ids, useful when you don't know the column id"
    )
    label_columns: Optional[LabelColumns] = None
    list_columns: Optional[List[str]] = Field(None, description='A list of columns')
    list_title: Optional[str] = Field(
        None,
        description='A title to render. Will be translated by babel',
        examples=['List Items'],
    )
    order_columns: Optional[List[str]] = Field(
        None, description='A list of allowed columns to sort'
    )
    result: Optional[List[DatabaseRestApiGetList]] = Field(
        None, description='The result from the get list query'
    )


class DatasetGetResponse(BaseModel):
    count: Optional[float] = Field(
        None, description='The total record count on the backend'
    )
    description_columns: Optional[DescriptionColumns] = None
    ids: Optional[List[str]] = Field(
        None, description="A list of item ids, useful when you don't know the column id"
    )
    label_columns: Optional[LabelColumns] = None
    list_columns: Optional[List[str]] = Field(None, description='A list of columns')
    list_title: Optional[str] = Field(
        None,
        description='A title to render. Will be translated by babel',
        examples=['List Items'],
    )
    order_columns: Optional[List[str]] = Field(
        None, description='A list of allowed columns to sort'
    )
    result: Optional[List[DatasetRestApiGetList]] = Field(
        None, description='The result from the get list query'
    )


class DatasetPkGetResponse(BaseModel):
    description_columns: Optional[DescriptionColumns] = None
    id: Optional[str] = Field(None, description='The item id')
    label_columns: Optional[LabelColumns] = None
    result: Optional[DatasetRestApiGet] = None
    show_columns: Optional[List[str]] = Field(None, description='A list of columns')
    show_title: Optional[str] = Field(
        None,
        description='A title to render. Will be translated by babel',
        examples=['Show Item Details'],
    )


class LogGetResponse(BaseModel):
    count: Optional[float] = Field(
        None, description='The total record count on the backend'
    )
    description_columns: Optional[DescriptionColumns] = None
    ids: Optional[List[str]] = Field(
        None, description="A list of item ids, useful when you don't know the column id"
    )
    label_columns: Optional[LabelColumns] = None
    list_columns: Optional[List[str]] = Field(None, description='A list of columns')
    list_title: Optional[str] = Field(
        None,
        description='A title to render. Will be translated by babel',
        examples=['List Items'],
    )
    order_columns: Optional[List[str]] = Field(
        None, description='A list of allowed columns to sort'
    )
    result: Optional[List[LogRestApiGetList]] = Field(
        None, description='The result from the get list query'
    )


class LogPkGetResponse(BaseModel):
    description_columns: Optional[DescriptionColumns] = None
    id: Optional[str] = Field(None, description='The item id')
    label_columns: Optional[LabelColumns] = None
    result: Optional[LogRestApiGet] = None
    show_columns: Optional[List[str]] = Field(None, description='A list of columns')
    show_title: Optional[str] = Field(
        None,
        description='A title to render. Will be translated by babel',
        examples=['Show Item Details'],
    )


class ReportPostResponse(BaseModel):
    id: Optional[float] = None
    result: Optional[ReportScheduleRestApiPost] = None


class ReportPkPutResponse(BaseModel):
    id: Optional[float] = None
    result: Optional[ReportScheduleRestApiPut] = None


class ChartDataQueryContextSchema(BaseModel):
    datasource: Optional[ChartDataDatasource] = None
    force: Optional[bool] = Field(
        None,
        description='Should the queries be forced to load from the source. Default: `false`',
    )
    queries: Optional[List[ChartDataQueryObject]] = None
    result_format: Optional[Any] = None
    result_type: Optional[Any] = None
